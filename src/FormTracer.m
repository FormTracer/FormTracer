(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(*"
Copyright (C) 2013-2017, Anton K. Cyrol, Mario Mitter, Jan M. Pawlowski and Nils Strodthoff.
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"*)


(* ::Input::Initialization:: *)
BeginPackage["FormTracer`"];

Unprotect@@Names["FormTracer`*"];
ClearAll@@Names["FormTracer`*"];


(* ::Input::Initialization:: *)
$FormTracerVersionNumber::usage="FormTracer version.";

FormTracer::usage="A Mathematica Tracing Package Using FORM";

FormTracer::incompatiblemathematicaversion="The FormTracer requires Mathematica 10.0 or higher. Please update your Mathematica version.";

FormTracer::formtracerdirectorynotfound="The FormTracer could not locate the FormTracer folder in your Applications folder. This is required for group traces.";

DefineLorentzTensors::usage="DefineLorentzTensors[lorentzDelta_,vector_,scalarProduct_,epsilon_:Null,diracDelta_:Null,gamma_:Null,gamma5_:Null,vectorspatial_:Null,scalarProductspatial_:Null] defines Lorentz and Dirac tensors. For each of the entries one can either pass a symbol (e.g. gamma[mu,i,j]) or a list with a symbol and the corresponding indices (e.g. {gamma[i,mu,j,anotherArg],mu,i,j}) if they do not follow the default order used in the documentation.

Example call:
DefineLorentzTensors[deltaLorentz[mu,nu],vec[p,mu],sp[p,q],eps[],deltaDirac[i,j],gamma[mu,i,j],gamma5[i,j]]

Finite temperature example call:
DefineLorentzTensors[deltaLorentz[mu,nu],vec[p,mu],sp[p,q],eps[],deltaDirac[i,j],gamma[mu,i,j],gamma5[i,j],vecs[p,mu],sps[p,q]]

DefineLorentzTensors clears all Lorentz tensor identities and all combined Lorentz tensors. They have to be declared after the syntax is specified.";

DefineLorentzTensors::badarg="Wrong syntax. Type ?DefineLorentzTensors for help!\nPlease check the arguments and their order.";

ClearLorentzTensorIdentities::usage="ClearLorentzTensorIdentities[] clears all Lorentz tensors identities.";

AddLorentzTensorIdentity::usage="AddLorentzTensorIdentity[identity_List] can be given a Lorentz tensor identities for speedup.

Brief syntax format:
identity = { left hand side, right hand side }

Example call (requires example call from DefineCombinedLorentzTensors):
AddLorentzTensorIdentity[{transProj[p,mu,rho]transProj[p,rho,nu],transProj[p,mu,nu]}]

All (combined) Lorentz tensors appearing in the identity must be known to the FormTracer before the identity is specified.
Otherwise you may use the long syntax format:
identity = { list of momenta, list of Lorentz indices, left hand side, right hand side }

Basic syntax must be specified using DefineLorentzTensors before Lorentz tensor identities can be added.";

AddLorentzTensorIdentity::closedindices="Dummy indices in Lorentz tensors identities are not supported.";

AddLorentzTensorIdentity::diracindices="Only Lorentz, no Dirac indices are supported in Lorentz tensors identities.";

DefineLorentzTensorIdentities::usage="DefineLorentzTensorIdentities[identities_List] can be given a list of tensor identities for speedup, see AddLorentzTensorIdentity. Clears all previously defined Lorentz tensor identities.

Example call (requires example call from DefineCombinedLorentzTensors):
DefineLorentzTensorIdentities[{
{transProj[p,mu,rho]transProj[p,rho,nu],transProj[p,mu,nu]},
{longProj[p,mu,rho]longProj[p,rho,nu],longProj[p,mu,nu]},
{transProj[p,mu,rho]longProj[p,rho,nu],0}
}]

Basic syntax must be specified with DefineLorentzTensors before Lorentz tensor identities can be defined.";

ClearCombinedLorentzTensors::usage="ClearCombinedLorentzTensors[] clears all combined Lorentz tensors.";

AddCombinedLorentzTensor::usage="AddCombinedLorentzTensor[combinedTensor_List] can be used to add a combined Lorentz tensor. The combined/explicit tensors must not contain dummy indices. 
Combined Lorentz tensors must be of the form combinedTensor = { combined tensor, explicit tensor }.

Example call:
AddCombinedLorentzTensor[{transProj[p,mu,nu],deltaLorentz[mu,nu]-vec[p,mu]vec[p,nu]/sp[p,p]}]

By default, the FormTacer considers all momenta of the explicit tensor as part of the abbreviated combined tensor. If this is not the case, i.e., if you have a momentum that does not appear as argument in the combined tensor, you must use the long form:
combinedTensor = { list of momenta, list of Lorentz indices, combined tensor, explicit tensor }

Example call:
AddCombinedLorentzTensor[{ {p}, {mu}, myP[p, mu], vec[p,mu]/sp[q,q] }]

Basic syntax must be specified with DefineLorentzTensors before combined Lorentz tensors can be added.";

AddCombinedLorentzTensor::badarg="Invalid combined tensor supplied. Type ?AddCombinedLorentzTensor for help!";

AddCombinedLorentzTensor::closedindices="Dummy indices in combined Lorentz tensors are not supported.";

AddCombinedLorentzTensor::diracindices="Only Lorentz, no Dirac indices are supported in combined Lorentz tensors.";

AddCombinedLorentzTensor::duplicate="Duplicate combined Lorentz tensor definition detected.";

AddCombinedLorentzTensor::momentumsums="Sums of momenta in function arguments are not supported.";

DefineCombinedLorentzTensors::usage="DefineCombinedLorentzTensors[combinedTensors_List] accepts a list of combined Lorentz tensors, see AddCombinedLorentzTensor. Clears all previously defined combined Lorentz tensors and Lorentz tensor identities.

Example call:
DefineCombinedLorentzTensors[{
{transProj[p,mu,nu],deltaLorentz[mu,nu]-vec[p,mu]vec[p,nu]/sp[p,p]},
{longProj[p,mu,nu],vec[p,mu]vec[p,nu]/sp[p,p]}
}]

Basic syntax must be specified with DefineLorentzTensors before combined Lorentz tensors can be defined.";

DefineGroupTensors::usage="DefineGroupTensors[listOfGroups_List] defines the groups. The argument has to be of the form
listOfGroups={
{groupTemplate1,groupName1,deltaAdj1,structureF1,deltaFund1,generatorT1,epsilonAdj1,epsilonFund1}},
{groupTemplate2,groupName2,deltaAdj2,structureF2,deltaFund2,generatorT2,epsilonAdj1,epsilonFund1},
... more groups ...
}

If you prefer your own names or numerical values instead of the default names for group dimensions and casimirs, you can also use 
group={groupTemplate,{groupName1,NR,cR,NA,cA,I2R},deltaAdj1,structureF1,deltaFund1,generatorT1}.
In case you specify something like
{groupTemplate,{groupName1,myNR,mycR},deltaAdj1,structureF1,deltaFund1,generatorT},
{NA,cA,I2R} will get the default names.

Example call:
DefineGroupTensors[{
{SUNfund,{color,3},deltaAdjCol[a,b],structureConstantCol[a,b,c],deltaFundCol[i,j],generatorCol[a,i,j]},
{SUNfund,{flavor,Nf},deltaAdj[a,b],structureConstant[a,b,c],deltaFund[i,j],generator[a,i,j]},
{GenericGroup,testing,generalAdjDelta[a,b],generalStructureConstant[a,b,c],generalDeltaFund[i,j],generalGenerator[a,i,j]}
}]

Evaluate ShowGroupTemplates[] to show available group templates.
Evaluate ShowGroupConstants[] to check your settings.
";

GenericGroup::usage="GenericGroup represents a generic simple compact Lie group which is traced with the generic color trace (to supplied as group template argument in DefineGroupTensors).";

SUNfund::usage="SUNfund represents the fundamental SU(N) group (to supplied as group template argument in DefineGroupTensors).";

SONfund::usage="SONfund represents the fundamental SO(N) group (to supplied as group template argument in DefineGroupTensors).";

SPNfund::usage="SPNfund represents the fundamental Sp(N) group (to supplied as group template argument in DefineGroupTensors).";

SU2fundexplicit::usage="SU2fundexplicit represents the fundamental SU(2) group which is traced with the explicit SU(2) tracing algorithm that supports explicit numerical indices, partial traces and transposed generators (to supplied as group template argument in DefineGroupTensors).";

SU3fundexplicit::usage="SU3fundexplicit represents the fundamental SU(3) group which is traced with the explicit SU(3) tracing algorithm that supports explicit numerical indices, partial traces and transposed generators (to supplied as group template argument in DefineGroupTensors).";

DefineGroupTensors::badarg="Wrong syntax. Type ?DefineGroupTensors for help!\nPlease check the arguments and their order.";

DefineGroupTensors::templatemissing="The group you want to specify is not known to the FormTracer. Use ShowGroupTemplates[] to see which groups are available.";

DefineGroupTensors::duplicategroupnames="Duplicate group names encountered. Please use unique group names!";

ClearGroupTensors::usage="ClearGroupTensors[] clears all groups.";

ShowGroupTemplates::usage="ShowGroupTemplates[] shows group templates that can be used in DefineGroupTensors.";

ShowGroupConstants::usage="ShowGroupConstants[] shows currently defined group constants.";

ShowGroupConstants::nogroups="No groups were defined. Use DefineGroupTensors to define them.";

FormTrace::usage="FormTrace[expr] takes the traces of the expression and returns it to Mathematica (or exports it as optimized C code).

The full form of FormTrace is given by:
FormTrace[expr_,prerepl_List:{},postrepl_List:{},filename_String:\"\",bracket_List:{},exportResVar_String:\"expr\",exportTmpVar_String:\"w\",exportVarType_String:\"double\"]

expr: can be either a single expression or a list of expressions that are added up after all traces have been taken 
prerepl: allows to specify lists of FORM replacement rules that are carried out prior to all contractions
	(use multiply replace_ where possible,use argument blocks for id inside subexpressions);
	also accepts list entries of the form {group,repl} and {LorentzFormRule,repl} where repl is only applied to the particular group/Lorentz objects;
	{PreambleFormFule,repl} allows to insert user-specific FORM code (like functions and declarations) in the preamble of the FORM file.
postrepl: allows to specify lists of FORM replacement rules that are carried out after the contractions (same syntax as for prerepl)
filename: if a filename is specified, the result will be exported to the file as optimized c code. Filename can also be a list {filename[, optimization[, format]]}.
bracket: if the expression is exported to C, the result can be bracketed according to the bracketing list
exportResVar: allows you to specify the name of the c variable which contains the result
exportTmpVar: is the name of the temporary c variable which is used for the evaluation
exportTmpVarType: is the type of exportResVar and exportTmpVar
";

FormTrace::badarg="FormTrace was called with invalid arguments. Aborting. Type ?FormTrace for help!";

FormTrace::formfailed="An unknow error occured in the FORM script.\nCheck whether there are undeclared variables and if so add them via AddExtraVars or DefineExtraVars.";

FormTrace::formnotfound="FormTracer could not find FORM. Please specify a valid FORM executable with DefineFormExecutable[path].";

FormTrace::specialchar="You have declared extra variables with special characters. This is not (and cannot) be supported if optimized ouput shall be generated.";

FormTrace::specialcharmomentum="You have declared momentum variables with special characters. This is not (and cannot) be supported if optimized ouput shall be generated.";

FormTrace::openindices="There are open indices:  `1` 
Tracing was aborted. Close all indices! If you do want to calculate partial traces, you can enable this feature by evaluating PartialTrace[True].";

FormTrace::openindicesexport="There are open indices:  `1`
Tracing was aborted. Close all indices! Exporting is and can only be supported for scalars.";

FormTrace::formeexitcode="FORM exited with error code `1`.";

FormTrace::formerror="FORM encountered an error:\n`1`";

FormTrace::nobracketing="Bracketing can only be used if output is saved to file.\nPlease perform the bracketing in Mathematica yourself.";

LorentzFormRule::usage="LorentzFormRule specifies that a replacement rule is only applied to Lorentz terms (passed as first list argument in FormTrace's prereplrule or postreplrule).";

PreambleFormRule::usage="PreambleFormRules specifies user-specific FORM code that is inserted in the preamble of the generated FORM file (passed as first list argument in FormTrace's prereplrule).";

FormTrace::invalidprerepl="Invalid pre-replacement rules discovered.";

FormTrace::invalidpostrepl="Invalid post replacement rules discovered.";

GetIndices::usage="GetIndices[expr] returns a list with all indices in expr.";

GetLorentzIndices::usage="GetLorentzIndices[expr] returns a list with all Lorentz indices in expr.";

GetDiracIndices::usage="GetDiracIndices[expr] returns a list with all Dirac indices in expr.";

GetOpenIndices::usage="GetOpenIndices[expr] returns a list with all open indices in expr.";

GetOpenLorentzIndices::usage="GetOpenLorentzIndices[expr] returns a list with all open Lorentz indices in expr.";

GetOpenDiracIndices::usage="GetOpenDiracIndices[expr] returns a list with all open Dirac indices in expr.";

GetClosedIndices::usage="GetClosedIndices[expr] returns a list with all closed indices in expr.";

GetClosedLorentzIndices::usage="GetClosedLorentzIndices[expr] returns a list with all closed Lorentz indices in expr.";

GetClosedDiracIndices::usage="GetClosedDiracIndices[expr] returns a list with all closed Dirac indices in expr.";

GetFundGroupIndices::usage="GetFundGroupIndices[expr,group] returns a list with all fundamental indices of group group in expr.\nThe group argument can be omitted if only one group is specified.";

GetAdjGroupIndices::usage="GetAdjGroupIndices[expr,group] returns a list with all adjoint indices of group group in expr.\nThe group argument can be omitted if only one group is specified.";

GetOpenFundGroupIndices::usage="GetOpenFundGroupIndices[expr,group] returns a list with all open fundamental indices of group group in expr.\nThe group argument can be omitted if only one group is specified.";

GetOpenAdjGroupIndices::usage="GetOpenAdjGroupIndices[expr,group] returns a list with all open adjoint indices of group group in expr.\nThe group argument can be omitted if only one group is specified.";

GetClosedFundGroupIndices::usage="GetClosedFundGroupIndices[expr,group] returns a list with all closed fundamental indices of group group in expr.\nThe group argument can be omitted if only one group is specified.";

GetClosedAdjGroupIndices::usage="GetClosedAdjGroupIndices[expr,group] returns a list with all closed adjoint indices of group group in expr.\nThe group argument can be omitted if only one group is specified.";

CheckLorentzTensorSums::usage="CheckLorentzTensorSums[expr] checks whether only Lorentz tensors of the same rank are summed.";

CheckDiracTensorSums::usage="CheckDiracTensorSums[expr] checks whether only Dirac tensors of the same rank are summed.";

CheckFundGroupTensorSums::usage="CheckFundGroupTensorSums[expr,group] checks whether only fundamental group tensors of the same rank are summed.\nThe group argument can be omitted if only one group is specified.";

CheckAdjGroupTensorSums::usage="CheckAdjGroupTensorSums[expr,group] checks whether only adjoint group tensors of the same rank are summed.\nThe group argument can be omitted if only one group is specified.";

CheckTensorSums::usage="CheckTensorSums[expr] checks all tensor sums in expr for consistency.";

CheckTensorSums::invalidsum="Invalid sum of tensors encountered: `1`.";

generateDimensionReplRules::invalidvars="The following variables cannot be used as group (or Lorentz) dimensions: `1`.";

General::grouparg="Please specify the group by providing a second argument with the group name.";

General::missingnotation="You must specify your notation.\nType ?DefineLorentzTensors or ?DefineGroupTensors for help!";

DefineFormExecutable::usage="DefineFormExecutable[path] sets the path the FormTracer looks for the FORM executable.

You can also use tform (a parallel version of FORM) by evaluating \"DefineFormExecutable[tform -wN]\", where you have to replace N with the number of worker threads you want to use. Note that the tracing part cannot be efficiently handled by tform and thus tform is usually slower than form. However, if you make heavy use of the FORM optimization routines (meaning, e.g., optimization with O3), tform can be much faster since the optimization is well parallelizable.";

DefineFormExecutable::badarg="DefineFormExecutable was called with an invalid argument. Argument must be a string.";

DefineFormExecutable::formnotfound="The specified FORM executable could not be found.";

DefineFormExecutable::cygwin="FORM exited with error code -1073741515. This hints at a problem with your Cygwin installation.";

DebuggingMode::usage="DebuggingMode[True/False] prints extra information if set to true.";

DebuggingMode::badarg="DebuggingMode was called with an invalid argument. Argument must be True or False.";

DisentangleLorentzStructures::usage="DisentangleLorentzStructures[True/False] if set to true, the Lorentz structures are disentangled.";

DisentangleLorentzStructures::badarg="DisentangleLorentzStructures was called with an invalid argument. Argument must be True or False.";

FiniteT::usage="FiniteT[True/False] if set to True, finite T is enabled.";

FiniteT::badarg="FiniteT was called with an invalid argument. Argument must be True or False.";

FastGamma5Trace::usage="FastGamma5Trace[True/False] determines whether the faster algorithm from arXiv:1506.04517 [hep-ph] is used instead of the Larin scheme to evaluate Dirac traces with a single gamma5 matrix in d!=4 dimensions.";

FastGamma5Trace::badarg="FastGamma5Trace was called with an invalid argument. Argument must be True or False.";

DefineFormAutoDeclareFunctions::usage="DefineAutoDeclareFunctions[cfuntions] can be used to define CFunctions that are autodeclared in FORM.
DefineAutoDeclareFunctions clears all previously defined autodeclare functions. Note that cfuntions must not contain substrings of standard Mathematica symbols that have to be translated into FORM code (e.g. (complex) I, Pi, Sqrt). 

Example call:
DefineFormAutoDeclareFunctions[myFunctionPrefix,myOtherPrefix]
lets you use any symbol or function that starts with myFunctionPrefix or myOtherPrefix.

You must not use special characters in this function. It is recommended to use DefineExtraVars/AddExtraVars unless you have many function/symbols starting with that prefix.
You cannot autodeclare the symbols (f, T, cA, cR, NA, NR, and I2R) that are used by the FORM color package internally.";

DefineExtraVars::usage="DefineExtraVars[vars] defines extra variables that might appear in your expressions. Clears all previously defined extra variables.";

AddExtraVars::usage="AddExtraVars[vars] adds an extra variable.";

GetExtraVars::usage="GetExtraVars[] returns a list with all extra variables.";

GetExtraVarsSynonyms::usage="GetExtraVarsSynonyms[] returns a list with all extra variables and their respective FORM synonyms (that changes whenever new extra variables are declared).";

ClearExtraVars::usage="ClearExtraVars[] clears all extra variable.";

MeasureEvaluationTime::usage="MeasureEvaluationTime[arg,message_String:\"\"] measures the absolute time arg needs to evaluate and prints the time in the format message<>time in seconds. The return value is the return value of arg.";

PartialTrace::usage="PartialTrace[True/False] enables/disables partial traces.";

PartialTrace::badarg="PartialTrace was called with an invalid argument. Argument must be True or False.";

AlwaysCheckTensorSums::usage="AlwaysCheckTensorSums[True/False] enables/disables consistency checks.";

AlwaysCheckTensorSums::badarg="AlwaysCheckTensorSums was called with an invalid argument. Argument must be True or False.";

DefineLorentzDimensions::usage="DefineLorentzDimensions[dim] sets the space dimension to dim.
DefineLorentzDimensions[dim, dimDirac]: sets the space and Dirac dimensions to dim and dimDirac, respectively.
The default dimensions are 4 for both dimensions.";

ConvertInput::usage="ConvertInput[expr_] converts input into FormTracer syntax.";

ExpandLorentzStructures::usage="ExpandLorentzStructures[expr_] dismantles Lorentz and Dirac tensors.";

ExpandLorentzStructures::failedconsistencycheck="An internal check revealed that you either entered an ill-defined expression or lorentzTensorProductToSortedLists has a serious bug! Please use DisentangleLorentzStructures[False].";

ExpandTerms::usage="ExpandTerms[expr_] dismantles an expression into the specified tensor classes.";

ImportFormResult::usage="ImportFormResult[filename_:String,deleteImportedFile_:False] imports a FORM result.";

ImportFormResult::noformoutput="An unknown FORM error occured!\nNo FORM output was generated.";

GenerateFormFile::usage="GenerateFormFile[expr_,formFileName_String,resFileName_String,optimization_String:\"\",format_String:\"mathematica\",prerepl_List:{},postrepl_List:{},bracket_List:{},exportResVar_String:\"expr\",exportTmpVar_String:\"w\",exportVarType_String:\"double\"] generates the form file and returns variable lists for Mathematica replacements.";

GenerateFormFile::duplicateindicesnames="Duplicate index names detected.";

getLatestVersionNumbers::pacletinfonotfound="Paclet info could not be found at `1`. Ensure that you have a working network connection.";

CheckForFormTracerUpdates::usage="CheckForFormTracerUpdates[] searches online for FormTracer updates.
CheckForFormTracerUpdates[quiet] with quiet=True suppresses warnings if paclet info is not found.";

ShowFormTracerChangeLog::usage="ShowFormTracerChangeLog[numberOfItems_Integer:15] shows the last numberOfItems entries in the changelog.
If an internet connection exists, it shows the latest changelog available. Otherwise it shows the local one.";

ShowFormTracerChangeLog::changelognotfound="Changelog could not be found (neither online nor local version).";

InstallFORM::usage="InstallFORM[] downloads the FORM executables for your operating system from http://www.github.com/vermaseren/form/releases and copies them into the FormTracer directory in Mathematica's application folder."; 

InstallFORM41::usage="InstallFORM41[] downloads the old FORM executable for your operating system from http://www.nikhef.nl/~form/maindir/binaries/binaries.html and copies it into the FormTracer directory in Mathematica's application folder.

This function is deprecated since a newer version of FORM is available via InstallFORM[].

However, use it if you are having trouble with the newer version."; 

InstallFORM::downloadfailed="The FormTracer failed to download the FORM executable from `1`. Ensure that you have a working network connection and writing permission to the FormTracer directory.";

InstallFORM::exenotknown="The FormTracer does not know where it can find FORM executables for your system architecture.";

General::allowinternetuse="You have forbidden Mathematica to access the internet. This function requires internet access.";

(*
InstallCygwin::usage="InstallCygwin[] downloads and starts the Cygwin setup executable from https://www.cygwin.com/.";

InstallCygwin::nowindows="Cygwin can and needs only be installed on Windows systems."; 

InstallCygwin::downloadfailed="The FormTracer failed to Cygwin from `1`. Ensure that you have a working network connection.";
*)

UpdateFormTracer::usage="UpdateFormTracer[] updates the FormTracer to the latest version.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
(*determine the FormTracer directory*)
formTracerDirectory=SelectFirst[{
FileNameJoin[{$UserBaseDirectory,"Applications","FormTracer"}],
FileNameJoin[{$BaseDirectory,"Applications","FormTracer"}],
FileNameJoin[{$InstallationDirectory,"AddOns","Applications","FormTracer"}],
FileNameJoin[{$InstallationDirectory,"AddOns","Packages","FormTracer"}],
FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","FormTracer"}]
},DirectoryQ[#]&];

If[formTracerDirectory===Missing["NotFound"],
Message[FormTracer::formtracerdirectorynotfound];
formTracerDirectory=FileNameJoin[{$UserBaseDirectory,"Applications","FormTracer"}]
];

$FormTracerVersionNumber=Quiet[Check[Version/.List@@Import[FileNameJoin[{formTracerDirectory,"PacletInfo.m"}]],"0.0.0"]];
{$FormTracerMainVersion,$FormTracerVersion,$FormTracerBuiltVersion}=First@StringReplace[$FormTracerVersionNumber,mV__~~"."~~v__~~"."~~bV__:>ToExpression/@{mV,v,bV}];

Print["
FormTracer "<>$FormTracerVersionNumber<>" loaded.

Copyright (C) 2013-2017, Anton K. Cyrol, Mario Mitter, Jan M. Pawlowski, and Nils Strodthoff.
FormTracer is released under the GNU General Public License version three or later.

If used in scientific publications, please acknowledge our work by citing:
A. K. Cyrol, M. Mitter, and N. Strodthoff, Comput. Phys. Commun. 219C (2017) 346-352, arXiv:1610.09331 [hep-ph]
"];

If[$VersionNumber<10,
Message[FormTracer::incompatiblemathematicaversion];
Abort[];
];


(* ::Input::Initialization:: *)
formTracerRepositoryAddress="https://raw.githubusercontent.com/FormTracer/FormTracer/master/";


(* ::Input::Initialization:: *)
getLatestVersionNumbers[quiet_]:=Module[{newVersionString,pacletInfoLocation=formTracerRepositoryAddress<>"src/PacletInfo.m"},
If[quiet,
newVersionString=Quiet[Check[Version/.List@@Import[pacletInfoLocation],""]];,
newVersionString=Quiet[Check[Version/.List@@Import[pacletInfoLocation],Message[getLatestVersionNumbers::pacletinfonotfound,formTracerRepositoryAddress];""],{Import::nffil,ReplaceAll::reps,FetchURL::httperr}];
];
Return[If[newVersionString==="",{0,0,0},
First@StringReplace[newVersionString,mainVersion__~~"."~~version__~~"."~~builtVersion__:>ToExpression/@{mainVersion,version,builtVersion}]
]];
];


(* ::Input::Initialization:: *)
CheckForFormTracerUpdates[quiet_:False]:=Module[{newVersionNumbers,newVersionString},
If[Not["AllowInternetUse" /. SystemInformation["Network"]],If[Not[quiet],Message[CheckForFormTracerUpdates::allowinternetuse]];Return[];];
newVersionNumbers=getLatestVersionNumbers[quiet];
newVersionString=StringJoin[Riffle[ToString/@newVersionNumbers,"."]];
If[newVersionNumbers=!={0,0,0},
If[newVersionNumbers[[1]]+newVersionNumbers[[2]]/10>$FormTracerMainVersion+$FormTracerVersion/10,Print["
FormTracer version "<>newVersionString<>" is available. You are currently using version "<> $FormTracerVersionNumber<>".
You are strongly advised to update as the new version may contain bugfixes. You can do so by evaluating UpdateFormTracer[].
Please be aware that syntax changes may have occured. We recommend to read the changelog before updating. The latest
changelog is available from ShowFormTracerChangeLog[].
"];,
If[newVersionNumbers[[1]]+newVersionNumbers[[2]]/10+newVersionNumbers[[3]]/100>$FormTracerMainVersion+$FormTracerVersion/10+$FormTracerBuiltVersion/100,Print["
FormTracer version "<>newVersionString<>" is available. You are currently using version "<> $FormTracerVersionNumber<>".
You can update the FormTracer by evaluating UpdateFormTracer[]. The changelog is available from ShowFormTracerChangeLog[].
"];,
If[Not[quiet],Print["You are already using the latest version of the FormTracer, version "<> $FormTracerVersionNumber<>"."];
];
];
];
];
];


(* ::Input::Initialization:: *)
UpdateFormTracer[]:=Module[{newVersionNumbers},
If[Not["AllowInternetUse" /. SystemInformation["Network"]],Message[UpdateFormTracer::allowinternetuse];Return[];];
newVersionNumbers=getLatestVersionNumbers[False];
If[newVersionNumbers=!={0,0,0},
If[newVersionNumbers[[1]]+newVersionNumbers[[2]]/10+newVersionNumbers[[3]]/100>$FormTracerMainVersion+$FormTracerVersion/10+$FormTracerBuiltVersion/100,
Import[formTracerRepositoryAddress<>"src/FormTracerInstaller.m"];,
Print["You are already using the latest version of the FormTracer, version "<> $FormTracerVersionNumber<>"."];
];
];
];


(* ::Input::Initialization:: *)
ShowFormTracerChangeLog[numberOfItems_Integer:15]:=Module[{changelog,changelogSplit},
(*try to obtain latest changelog online, otherwise show the local one*)
changelog=Quiet[Check[Import[formTracerRepositoryAddress<>"src/CHANGELOG","String"],Import[FileNameJoin[{formTracerDirectory,"CHANGELOG"}],"String"]]];
If[changelog===$Failed,Message[ShowFormTracerChangeLog::changelognotfound];,
changelogSplit=StringSplit[changelog,"\n\n"];
Return[StringTrim[StringJoin@Riffle[Take[changelogSplit,Min[Length[changelogSplit],numberOfItems+1]],"\n"]]];
];
];


(* ::Input::Initialization:: *)
InstallFORM[]:=Module[{archiveLocation,localArchiveLocation,extractedArchiveLocation,fullArchiveName,archiveName,exeLocation},
If[$OperatingSystem==="Windows",
Print["
Installing FORM 4.1 since compiled executables of the 
newer version FORM 4.2 are not available for Windows.
"];
InstallFORM41[];
];
If[Not["AllowInternetUse" /. SystemInformation["Network"]],Message[InstallFORM::allowinternetuse];Return[];];

archiveLocation=Switch[$OperatingSystem,
"Unix","https://github.com/vermaseren/form/releases/download/v4.2.0/form-4.2.0-x86_64-linux.tar.gz",
"MacOSX","https://github.com/vermaseren/form/releases/download/v4.2.0/form-4.2.0-x86_64-osx.tar.gz",
(*"Windows","http://www.nikhef.nl/~form/maindir/binaries/cygwin/form.exe",*)
_,Message[InstallFORM::exenotknown];Abort[];];
fullArchiveName=Last[FileNameSplit[archiveLocation]];
archiveName=StringDrop[fullArchiveName,-7];(*without .tar.gz ending*)
localArchiveLocation=FileNameJoin[{$TemporaryDirectory,fullArchiveName}];
extractedArchiveLocation=FileNameJoin[{formTracerDirectory,archiveName}];
exeLocation=First[defaultFormExecutables];

(* download archiv *)
Quiet[Check[URLDownload[archiveLocation,localArchiveLocation],Message[InstallFORM::downloadfailed,exeLocation]],URLFetch::offline];
(* extract archiv *)
If[DirectoryQ[extractedArchiveLocation],DeleteDirectory[extractedArchiveLocation,DeleteContents->True];];
ExtractArchive[localArchiveLocation,formTracerDirectory];
Quiet[DeleteFile[localArchiveLocation]];
(* copy file to main FormTracer folder *)
If[FileExistsQ[exeLocation],DeleteFile[exeLocation]];
CopyFile[FileNameJoin[{extractedArchiveLocation,"form"}],exeLocation];
(* mark as executable, just in case, should not be necessary *)
Quiet[Run["chmod +x "<>exeLocation]];

If[$OperatingSystem==="MacOSX",Print["
Note that you may need to install the GNU Multiple 
Precision Arithmetic Library (GMP), which you
obtain from https://gmplib.org/"];
];

DefineFormExecutable[exeLocation];
];


(* ::Input::Initialization:: *)
InstallFORM41[]:=Module[{exeLocation,cygwinDownloadSuccessfull,cygwinDLL="http://www.thphys.uni-heidelberg.de/~cyrol/downloads/cygwin1.dll"},
If[Not["AllowInternetUse" /. SystemInformation["Network"]],Message[InstallFORM::allowinternetuse];Return[];];
exeLocation="http://www.nikhef.nl/~form/maindir/binaries/"<>Switch[$OperatingSystem,
"Unix",If[$ProcessorType==="x86","linux32/form","linux64/form"],
"MacOSX",If[$ProcessorType==="x86","apple/form32","apple/form"],
"Windows","cygwin/form.exe",
_,Message[InstallFORM::exenotknown];Abort[];];

Quiet[Check[URLDownload[exeLocation,First[defaultFormExecutables]],Message[InstallFORM::downloadfailed,exeLocation]],URLFetch::offline];

If[$OperatingSystem==="Windows",
(* Windows *)
If[ChoiceDialog["To run FORM under Windows, you need to install (the 
32 bit version of) Cygwin (see https://www.cygwin.com/).

However, FormTracer can also download the DLL required by FORM from
"<>cygwinDLL<>"

Do you want to download the DLL now?",
WindowTitle->"Download cygwin1.dll?",WindowSize->{Medium,All}],
cygwinDownloadSuccessfull=True;
Check[URLDownload[cygwinDLL,FileNameJoin[{formTracerDirectory,"cygwin1.dll"}]];,cygwinDownloadSuccessfull=False;];
If[cygwinDownloadSuccessfull,Print["Cygwin1.dll was successfully downloaded."];];
];
,
(* Linux and MacOSX *)
Run["chmod +x "<>First[defaultFormExecutables]];
If[$OperatingSystem==="MacOSX",Print["
Note that you may need to install the GNU Multiple 
Precision Arithmetic Library (GMP), which you
obtain from https://gmplib.org/"];
];
];
DefineFormExecutable[First[defaultFormExecutables]];
];

(*
InstallCygwin[]:=Module[{setupExe,setupExeOnline,
(* always use 32 bit executable until the 64 bit version of form.exe is available *)
setupExeName="setup-x86.exe"
(*If[$ProcessorType==="x86","setup-x86.exe","setup-x86_64.exe"]*)
},
If[$OperatingSystem=!="Windows",Message[InstallCygwin::nowindows]; Return[];];
setupExeOnline="https://cygwin.com/"<>setupExeName;
setupExe=FileNameJoin[{$TemporaryDirectory,setupExeName}];
(* download executable *)
Quiet[Check[FindFile@URLDownload[setupExeOnline,setupExe],Message[InstallCygwin::downloadfailed,setupExeOnline]],URLFetch::offline];
(* grant the user permission (not sure wether that is necessary but it cannot harm) *)
Quiet[Run["CACLS "<>setupExe<>" /e /p "<>$UserName<>":f"];];
(* install Cygwin *)
Run[setupExe];
(* delete the install file *)
Quiet[DeleteFile[setupExe]];
];
*)


(* ::Input::Initialization:: *)
(*check for updates at startup*)
If["AllowInternetUse" /. SystemInformation["Network"],CheckForFormTracerUpdates[True];];


(* ::Input::Initialization:: *)
defaultFormExecutables={
FileNameJoin[{formTracerDirectory,If[$OperatingSystem==="Windows","form.exe","form"]}](*has to be the first entry due to InstallFORM*),
"form",(*should work if form lies in any executable path*)
FileNameJoin[{$PathnameSeparator,"usr","bin","form"}],
FileNameJoin[{$PathnameSeparator,"usr","local","bin","form"}],
FileNameJoin[{$PathnameSeparator,"opt","bin","form"}],
FileNameJoin[Flatten@{$UserBaseDirectory,"Applications","FormLink","bin",Switch[$OperatingSystem,"Unix",{"linux64","form"},"MacOSX",{"macosx64","form"},"Windows",{"windows","form.exe"}]}]
};
formExecutable="";(* is set automatically below, can be changed by DefineFormExecutable[path]*) 
formChecked=False;
formInfo="";
debuggingMode=False;
(* disentangleLorentzStructures can be False despite disentangleLorentzStructuresSwitch==True, if partialtrace\[Equal]True*)
disentangleLorentzStructuresSwitch=False;
disentangleLorentzStructures=disentangleLorentzStructuresSwitch;
finiteTenabled=False;
cacheFilesDirectory="FormTracerCache";
partialtrace=False;
fastgamma5tracedneq4=False;
checkTensorSums=False;
lorentzDimensions={4,4};


(* ::Input::Initialization:: *)
checkFormExecutable[quietMode_:False]:=Module[{formProcessResult,formResponse,formExitCode},
(*Don't check whether FORM works if it was already checked.*)
If[formChecked,Return[True(*=formChecked*)]];
(*Check if FORM works*)
formProcessResult=Quiet[RunProcess[{formExecutable,"-v"}]];
formResponse=formProcessResult["StandardOutput"];
formExitCode=formProcessResult["ExitCode"];
formChecked=formExitCode===0;
If[formChecked,
formInfo=StringTrim[StringJoin[Select[StringSplit[formResponse,EndOfLine],Not@StringContainsQ[#,"out of"]&]]];,
formInfo="";
If[Not[quietMode],
Message[DefineFormExecutable::formnotfound];
If[formExitCode===-1073741515&&$OperatingSystem==="Windows",Message[DefineFormExecutable::cygwin];];
];
];
Return[formChecked];
];

(*try to find the FORM executable trying all commands in defaultFormExecutables *)
If[Catch[Do[
formExecutable=tmpFormExecutable;
If[checkFormExecutable[True],Throw[$Success]]
,{tmpFormExecutable,defaultFormExecutables}]]===$Success,
Print["Using "<>formInfo<>"."];,
Print["FormTracer could not locate the FORM executable. Please install FORM via InstallFORM[].
If FORM is installed on your system, use DefineFormExecutable[pathToExecutable] to specify the path. 
You may also obtain FORM at http://www.nikhef.nl/~form or from https://github.com/vermaseren/form."];
];

DefineFormExecutable[path_String]:=Module[{},
formExecutable=path;
formChecked=False;
If[checkFormExecutable[],Print[formInfo];];
];
DefineFormExecutable[___]:=Message[DefineFormExecutable::badarg];


DisentangleLorentzStructures[yesno_/;BooleanQ[yesno]]:=Module[{},
disentangleLorentzStructuresSwitch=yesno;
If[partialtrace,
Print[If[disentangleLorentzStructuresSwitch,"Lorentz structures are disentangled once you have deactivated partial traces.","Lorentz structures are not disentangled."]];
,
disentangleLorentzStructures=disentangleLorentzStructuresSwitch;
Print[If[disentangleLorentzStructures,"Lorentz structures are disentangled.","Lorentz structures are not disentangled."]];
];
];
DisentangleLorentzStructures[___]:=Message[DisentangleLorentzStructures::badarg];

FiniteT[yesno_/;BooleanQ[yesno]]:=Print[If[enableFiniteT[yesno],"Finite T enabled.","Finite T disabled."]];
FiniteT[___]:=Message[FiniteT::badarg];

FastGamma5Trace[yesno_/;BooleanQ[yesno]]:=Module[{},
fastgamma5tracedneq4=yesno;
Print["Fast gamma5 trace in d!=4 "<>If[fastgamma5tracedneq4,"enabled","disabled"]<>"."];
];
FastGamma5Trace[___]:=Message[FastGamma5Trace::badarg];

DebuggingMode[yesno_/;BooleanQ[yesno]]:=Module[{},
debuggingMode=yesno;
Print["Debugging mode "<>If[debuggingMode,"enabled","disabled"]<>"."];
];
DebuggingMode[___]:=Message[DebuggingMode::badarg];

PartialTrace[yesno_/;BooleanQ[yesno]]:=Module[{},
partialtrace=yesno;
If[yesno,
disentangleLorentzStructures=False;
Print["Partial traces enabled. Keep in mind that this leads to performance losses and does not allow for consistency checks."];
If[disentangleLorentzStructures!=disentangleLorentzStructuresSwitch,
Print["Lorentz structures are no longer disentangled (until you deactivate partial traces again)."];
];
,
Print["Partial traces disabled."];
disentangleLorentzStructures=disentangleLorentzStructuresSwitch;
If[disentangleLorentzStructures,Print["Lorentz structures are now disentangled."];];
];
];
PartialTrace[___]:=Message[PartialTrace::badarg];


AlwaysCheckTensorSums[___]:=Message[AlwaysCheckTensorSums::badarg];

AlwaysCheckTensorSums[yesno_/;BooleanQ[yesno]]:=Module[{},
checkTensorSums=yesno;
Print[If[checkTensorSums,
"Tensors sums are checked for consistency.\nKeep in mind that this leads to performance losses.",
If[debuggingMode,"Note that tensor sums are still being checked as long as the debugging mode is activated.",
"Tensors sums are not checked for consistency."]
]];
];
AlwaysCheckTensorSums[___]:=Message[AlwaysCheckTensorSums::badarg];

DefineLorentzDimensions[dim_]:=DefineLorentzDimensions[{dim,Last[lorentzDimensions]}];
DefineLorentzDimensions[dim_,dimSpinor_]:=DefineLorentzDimensions[{dim,dimSpinor}];
DefineLorentzDimensions[dim_List]:=Module[{tmpCombinedLorentzTensorInputCache=combinedLorentzTensorInputCache},
(* Combined Lorentz tensors must be re-declared since the traces of the squared combined tensors is cached and these can change. *) 
ClearCombinedLorentzTensors[];
lorentzDimensions=If[Length[dim]===2,dim,{First[dim],Last[lorentzDimensions]}];
dimLorVars=Variables[lorentzDimensions];
generateDimensionReplRules[];
DefineCombinedLorentzTensors[tmpCombinedLorentzTensorInputCache];
];


(* ::Input::Initialization:: *)
lorDummyPrefix="lorDummy";
spiDummyPrefix="spiDummy";

tempPartialTraceDummy=FormTracer`Private`TempDummy;
adjGroupDummyPrefix="adj";
fundGroupDummyPrefix="fund";
lorDummyPrefixFORM="lorFORMDummy";
spiDummyPrefixFORM="spiFORMDummy";

lorentzTensorReplacementRulesInput={};
lorentzTensorReplacementRulesOutput={};
lorentzTensorReplacementRulesOutputTraced={};
lorentzTensorReplacementRulesOutputPartiallyTraced={};

groupTensorReplacementRulesInput={};
groupTensorReplacementRulesOutput={};
groupTensorReplacementRulesOutputTraced={};
groupTensorReplacementRulesOutputPartiallyTraced={};

formLorentzTensorIdentities={};
combinedTensorIdentities={};
combinedTensorNames={};
combinedTensorSquaresReplRules={};

(* All extra vars are replaced bei Unique["FTxextraVar"] in Form. Thus, extra vars can be special characters. *)
extraFormVarPrefix="FTxextraVar";
extraFormVarsList={};(* Format of this list: {{symbol,FTxextraVar34234},{anotherSymbol,FTxextraVar34235}}*)
extraFormVarsListExportDeclare={};
extraFormVarsListInputConversion={};
extraFormVarsListOutputConversion={};
extraFormVarsListInputConversionExport={};
extraFormVarsListOutputConversionExport="";(*Is a string because in this case the replacement is done in FORM*)

extraFormDimVarPrefix="FTxextraDimVar";(* extra dim vars have to be declared as symbol *)
dimReplVarsSynonyms={};
dimVarRulesInput={};
dimLorVars=Variables[lorentzDimensions];
dimGroupVars={};
dimVars=Join[dimLorVars,dimGroupVars]/.dimVarRulesInput;

(* All items in the following list declared via AutoDeclare CFunction x,y,z. Thus, xBla is also an valid input. Should be used with care. *)
formCFunctionAutoDeclareListBasic={extraFormVarPrefix};
formCFunctionAutoDeclareList=formCFunctionAutoDeclareListBasic;


(* ::Input::Initialization:: *)
getGroupTensors[group_]:={FTxdeltaAdj[group,_,_],FTxdeltaFund[group,_,_],FTxF[group,_,_,_],FTxT[group,_,_,_],FTxepsAdj[group,__],FTxepsFund[group,__]};

adjIndicesFromExprRules[group_]:={
FTxdeltaAdj[group,x_,y_]:>{x,y},
FTxF[group,x_,y_,z_]:>{x,y,z},
FTxT[group,x_,y_,z_]:>{x},
FTxepsAdj[group,x__]:>{x}
};

fundIndicesFromExprRules[group_]:={
FTxdeltaFund[group,x_,y_]:>{x,y},
FTxT[group,x_,y_,z_]:>{y,z},
FTxepsFund[group,x__]:>{x}
};

(*the order is relevant in removeSquaredTensorsRulesT0*)
formColorPackageExtVars={Global`NR,Global`cR,Global`NA,Global`cA,Global`I2R};

(*last argument is the tracing algorithm*)
formColorPackageGroupTemplates={
{FormTracer`GenericGroup,formColorPackageExtVars,1},
{FormTracer`SUNfund, {Global`NR,(Global`NR^2-1)/(2*Global`NR),(Global`NR^2-1),Global`NR,1/2},2},
{FormTracer`SONfund, {Global`NR,(Global`NR-1)/2,Global`NR*(Global`NR-1)/2,Global`NR-2,1},3},
{FormTracer`SPNfund, {Global`NR,(Global`NR+1)/4,Global`NR*(Global`NR+1)/2,(Global`NR+2)/2,1/2},4},
{FormTracer`SU2fundexplicit, {2,3/4,3,2,1/2},5},
{FormTracer`SU3fundexplicit, {3,4/3,8,3,1/2},6}
};
(* first argument: algorithm; second: header; third: 1 requires dimension NA, 2 requires dimension NR, 0 nothing*)
formColorPackageTracingAlgorithms={{"color","color.h",1},{"SUNfund","special_color.h",2},{"SONfund","special_color.h",2},{"SPNfund","special_color.h",2},{"SU2fundexplicit","special_color.h",1},{"SU3fundexplicit","special_color.h",2}};

formColorPackageGenericD=ToString/@{d33,d44,d55,d433,d66,d633,d543,d444,d3333,d77,d743,d653,d644,d554,d5333,d4433a,d4433b,d4433c,d88,d853,d844,d763,d754,d7333,d664,d655,d6433a,d6433b,d6433c,d5533a,d5533b,d5533c,d5533d,d5443a,d5443b,d5443c,d5443d,d4444a,d4444b,d43333a,d43333b};

(*prefix for GenericD replacements*)
prefixColorPackageGenericD="grp";
(*postfix for scalar products of group vectors- gets appended to prefixColorPackageGenericD*)
postfixColorPackagesp="sp";
(*prefix for the group vectors coming out of color package*)
prefixColorPackagegrpvecsym="grpvecx";
(*maximal order up to which grpvecsyms are replaced*)
grpvecsymreplorder=2;

forbiddenFormVars=Join[{"f","T","cA","cR","NA","NR","I2R"},formColorPackageGenericD];

prefixListLorentzDirac={"mom","lor","spi"};
prefixListIndices=prefixListLorentzDirac;
groupTypes={};
groupNames={};
shortGroupNames={};
groupConstantsTable={};
groupTracingAlgorithms={};
formPreGroupTraceIdentities={};
formPostGroupRenamingRules={};
formGenericDReplacementRules={};
formPostGroupTensorRenamingRules={};
groupTensorsList={};

basicLorentzTensorsT0={FTxdeltaLorentz[_,_],FTxdeltaDirac[_,_],FTxvec[_,_],FTxgamma[_,_,_],FTxgamma5[_,_],FTxepsLorentz[__]};
basicLorentzTensorsT={FTxvecs[_,_]};
basicLorentzTensors=basicLorentzTensorsT0;
lorentzTensors=basicLorentzTensors;


basicLorentzFromExprRulesT0={
FTxdeltaLorentz[x_,y_]:>{x,y},
FTxvec[x_,y_]:>{y},
FTxgamma[x_,y_,z_]:>{x},
FTxepsLorentz[x__]:>{x}
};
basicLorentzFromExprRulesT={
FTxvecs[x_,y_]:>{y}
};
basicLorentzFromExprRules=basicLorentzFromExprRulesT0;
lorentzFromExprRules=basicLorentzFromExprRules;


spinorFromExprRules={
FTxgamma[x_,y_,z_]:>{y,z},
FTxgamma5[y_,z_]:>{y,z},
FTxdeltaDirac[x_,y_]:>{x,y}
};


basicMomentumFromExprRulesT0={
FTxvec[x_,y_]:>{x},
FTxsp[x_,y_]:>{x,y}
};
basicMomentumFromExprRulesT={
FTxvecs[x_,y_]:>{x},
FTxsps[x_,y_]:>{x,y}
};

basicMomentumFromExprRules=basicMomentumFromExprRulesT0;
momentumFromExprRules=basicMomentumFromExprRules;

basicCombinedMomentumReplT0={
FTxvec[p_Plus,mu_]:>FTxvec[momentumSum[p],mu],
FTxvec[p_Times,mu_]:>p[[1]]*FTxvec[p[[2]],mu],
FTxsp[p_Plus,q_]:>FTxsp[momentumSum[p],q],
FTxsp[p_,q_Plus]:>FTxsp[p,momentumSum[q]],
FTxsp[p_Times,q_]:>p[[1]]*FTxsp[p[[2]],q],
FTxsp[p_,q_Times]:>q[[1]]*FTxsp[p,q[[2]]]
}
basicCombinedMomentumReplT={
FTxvecs[p_Plus,mu_]:>FTxvecs[momentumSum[p],mu],
FTxvecs[p_Times,mu_]:>p[[1]]*FTxvecs[p[[2]],mu],
FTxsps[p_Plus,q_]:>FTxsps[momentumSum[p],q],
FTxsps[p_,q_Plus]:>FTxsps[p,momentumSum[q]],
FTxsps[p_Times,q_]:>p[[1]]*FTxsps[p[[2]],q],
FTxsps[p_,q_Times]:>q[[1]]*FTxsps[p,q[[2]]]
}
basicCombinedMomentumRepl=basicCombinedMomentumReplT0;
combinedMomentumRepl=basicCombinedMomentumRepl;


(* ::Input::Initialization:: *)
generateDimensionReplRules[]:=Module[{dimReplVars,forbiddenDimVars},
forbiddenDimVars=Complement[forbiddenFormVars,ToString/@formColorPackageExtVars];
dimVars=Join[dimLorVars,dimGroupVars];
If[AnyTrue[dimVars,MemberQ[forbiddenDimVars,ToString[#]]&],Message[generateDimensionReplRules::invalidvars,forbiddenDimVars];Abort[];];
dimReplVars=If[Length[groupNames]===0,{},Select[Join[dimLorVars,If[Length[groupNames]>1,dimGroupVars,{}]],MemberQ[ToString/@formColorPackageExtVars,ToString[#]]&]];
dimReplVarsSynonyms=getSynonymList[dimReplVars,extraFormDimVarPrefix];
dimVarRulesInput=Dispatch[Map[First[#]->Last[#]&,dimReplVarsSynonyms]];
dimVars=dimVars/.dimVarRulesInput;
];


(* ::Input::Initialization:: *)
addbar[s_Symbol]:=ToExpression[ToString[s]<>"_"];
barrepl[s_,vars_List]:=s/.Table[var->addbar[var],{var,vars}];
extractExprAndVars[arg_,numberOfArgs_Integer]:=If[VectorQ[arg],{First[arg],Rest[arg]},{arg,Take[List@@arg,-numberOfArgs]}];


(* ::Input::Initialization:: *)
(*
outputRules doesn't act on FORM output (e.g. just for expand terms),
outputRulesTraced acting on FORM output with partial trace disabled,
outputRulesPartiallyTraced acting on FORM output with partial trace enabled,
rules in outputRulesTraced are also added to outputRulesPartiallyTraced at the end
*)
DefineLorentzTensors[___]:=Message[DefineLorentzTensors::badarg];
DefineLorentzTensors[lorentzDelta_,vector_,scalarProduct_,epsilon_:Null,spinorDelta_:Null,gamma_:Null,gamma5_:Null,vectorspatial_:Null,scalarProductspatial_:Null]:=Module[{inputRules={},outputRules={},outputRulesTraced={},outputRulesPartiallyTraced={},tmpExpr,tmpVars},
(* Clear combined Lorentz tensors and Lorentz tensor identities since they may use an old syntax which would lead to errors. *)
ClearCombinedLorentzTensors[];
ClearLorentzTensorIdentities[];

Quiet[Check[
(*lorentz delta replacement rule*)
{tmpExpr,tmpVars}=extractExprAndVars[lorentzDelta,2];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxdeltaLorentz[tmpVars[[1]],tmpVars[[2]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxdeltaLorentz[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesPartiallyTraced,barrepl[Global`FTxdeltaLorentz[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
(*vector replacement rule*)
{tmpExpr,tmpVars}=extractExprAndVars[vector,2];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxvec[tmpVars[[1]],tmpVars[[2]]]]];
(*special rule for shorthand vecs in gamma strings*)
If[gamma=!=Null,AppendTo[inputRules,barrepl[Head[tmpExpr]@@(Drop[List@@tmpExpr,-1]),Drop[tmpVars,-1]]:>Evaluate[FormTracer`Private`FTxvec[tmpVars[[1]]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxvec[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesTraced,barrepl[Global`FTxvec[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
(*special rule for shorthand vecs in gamma strings*)
If[gamma=!=Null,AppendTo[outputRulesPartiallyTraced,barrepl[Global`FTxvec[tmpVars[[1]]],tmpVars]:>Evaluate[Drop[tmpExpr,-1]]]];
(*scalar product replacement rule*)
{tmpExpr,tmpVars}=extractExprAndVars[scalarProduct,2];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxsp[tmpVars[[1]],tmpVars[[2]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxsp[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesTraced,barrepl[Global`FTxsp[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
(*optional epsilon replacement rule*)
If[epsilon=!=Null,
AppendTo[inputRules,Head[epsilon][a__]:>FormTracer`Private`FTxepsLorentz[a]];
AppendTo[outputRules,FormTracer`Private`FTxepsLorentz[a__]:>Head[epsilon][a]];
AppendTo[outputRulesTraced,Global`FTxepsLorentz[a__]:>Head[epsilon][a]];
];
(*optional spinor delta replacement rule*)
If[spinorDelta=!=Null,
{tmpExpr,tmpVars}=extractExprAndVars[spinorDelta,2];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxdeltaDirac[tmpVars[[1]],tmpVars[[2]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxdeltaDirac[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesPartiallyTraced,barrepl[Global`FTxdeltaDirac[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
];
(*optional gamma replacement rule*)
If[gamma=!=Null,
{tmpExpr,tmpVars}=extractExprAndVars[gamma,3];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxgamma[tmpVars[[1]],tmpVars[[2]],tmpVars[[3]]]]];
(*special rule for closed gamma strings*)
AppendTo[inputRules,barrepl[Head[tmpExpr]@@(Drop[List@@tmpExpr,-2]),Drop[tmpVars,-2]]:>Evaluate[FormTracer`Private`FTxgamma[tmpVars[[1]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxgamma[tmpVars[[1]],tmpVars[[2]],tmpVars[[3]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesPartiallyTraced, barrepl[Global`FTxgamma[tmpVars[[1]],tmpVars[[2]],tmpVars[[3]]],tmpVars]:>Evaluate[tmpExpr]];
];
(*optional gamma5 replacement rule*)
If[gamma5=!=Null,
{tmpExpr,tmpVars}=extractExprAndVars[gamma5,2];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxgamma5[tmpVars[[1]],tmpVars[[2]]]]];
(*special rule for shorthand gamma5 in gamma strings*)
AppendTo[inputRules,Head[tmpExpr]:>FormTracer`Private`FTxgamma5];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxgamma5[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesPartiallyTraced,barrepl[Global`FTxgamma5[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
];
(*optional vecs replacement rule*)
If[vectorspatial=!=Null,
{tmpExpr,tmpVars}=extractExprAndVars[vectorspatial,2];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxvecs[tmpVars[[1]],tmpVars[[2]]]]];
(*special rule for shorthand vecs in gamma strings*)
AppendTo[inputRules,barrepl[Head[tmpExpr]@@(Drop[List@@tmpExpr,-1]),Drop[tmpVars,-1]]:>Evaluate[FormTracer`Private`FTxvecs[tmpVars[[1]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxvecs[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesTraced,barrepl[Global`FTxvecs[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
(*special rule for shorthand vecs in gamma strings*)
AppendTo[outputRulesPartiallyTraced,barrepl[Global`FTxvecs[tmpVars[[1]]],tmpVars]:>Evaluate[Drop[tmpExpr,-1]]];
];
(*optional sp3 replacement rule*)
If[scalarProductspatial=!=Null,
{tmpExpr,tmpVars}=extractExprAndVars[scalarProductspatial,2];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxsps[tmpVars[[1]],tmpVars[[2]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxsps[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesTraced,barrepl[Global`FTxsps[tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
];
,Message[DefineLorentzTensors::badarg]],{Take::take,Part::partw,General::stop}];

lorentzTensorReplacementRulesInput=Dispatch[inputRules];
lorentzTensorReplacementRulesOutput=Dispatch[outputRules];
lorentzTensorReplacementRulesOutputTraced=Dispatch[outputRulesTraced];
lorentzTensorReplacementRulesOutputPartiallyTraced=Dispatch[Join[outputRulesTraced,outputRulesPartiallyTraced]];

enableFiniteT[vectorspatial=!=Null||scalarProductspatial=!=Null];
];


(* ::Input::Initialization:: *)
getGroupTensorRules[{type_,group_,deltaAdj_,structureF_,deltaFund_:Null,generatorT_:Null,epsilonAdj_:Null,epsilonFund_:Null}]:=Module[
{groupName=If[Head[group]===List,First[group],group],inputRules={},outputRules={},outputRulesTraced={},outputRulesPartiallyTraced={},tmpExpr,tmpVars},
(*delta adj replacement rule*)
{tmpExpr,tmpVars}=extractExprAndVars[deltaAdj,2];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxdeltaAdj[groupName,tmpVars[[1]],tmpVars[[2]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxdeltaAdj[groupName,tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesPartiallyTraced,barrepl[Global`FTxdeltaAdj[groupName,tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];(*FT context as deltas and epsilons will be converted internally*)
(*structureF replacement rule*)
{tmpExpr,tmpVars}=extractExprAndVars[structureF,3];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxF[groupName,tmpVars[[1]],tmpVars[[2]],tmpVars[[3]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxF[groupName,tmpVars[[1]],tmpVars[[2]],tmpVars[[3]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesPartiallyTraced,barrepl[Global`FTxF[groupName,tmpVars[[1]],tmpVars[[2]],tmpVars[[3]]],tmpVars]:>Evaluate[tmpExpr]];
(*optional delta fund replacement rule*)
If[deltaFund===Null,Return[{inputRules,outputRules,outputRulesTraced,outputRulesPartiallyTraced}]];
{tmpExpr,tmpVars}=extractExprAndVars[deltaFund,2];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxdeltaFund[groupName,tmpVars[[1]],tmpVars[[2]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxdeltaFund[groupName,tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesPartiallyTraced,barrepl[Global`FTxdeltaFund[groupName,tmpVars[[1]],tmpVars[[2]]],tmpVars]:>Evaluate[tmpExpr]];
(*optional T replacement rule*)
If[generatorT===Null,Return[{inputRules,outputRules,outputRulesTraced,outputRulesPartiallyTraced}]];
{tmpExpr,tmpVars}=extractExprAndVars[generatorT,3];
AppendTo[inputRules,barrepl[tmpExpr,tmpVars]:>Evaluate[FormTracer`Private`FTxT[groupName,tmpVars[[1]],tmpVars[[2]],tmpVars[[3]]]]];
AppendTo[outputRules,barrepl[FormTracer`Private`FTxT[groupName,tmpVars[[1]],tmpVars[[2]],tmpVars[[3]]],tmpVars]:>Evaluate[tmpExpr]];
AppendTo[outputRulesPartiallyTraced,barrepl[Global`FTxT[groupName,tmpVars[[1]],tmpVars[[2]],tmpVars[[3]]],tmpVars]:>Evaluate[tmpExpr]];
(*optional epsilon adj replacement rule*)
If[epsilonAdj===Null,Return[{inputRules,outputRules,outputRulesTraced,outputRulesPartiallyTraced}]];
AppendTo[inputRules,Head[epsilonAdj][a__]:>FormTracer`Private`FTxepsAdj[groupName,a]];
AppendTo[outputRules,FormTracer`Private`FTxepsAdj[groupName,a__]:>Head[epsilonAdj][a]];
AppendTo[outputRulesPartiallyTraced,Global`FTxepsAdj[groupName,a__]:>Head[epsilonAdj][a]];
(*optional epsilon fund replacement rule*)
If[epsilonFund===Null,Return[{inputRules,outputRules,outputRulesTraced,outputRulesPartiallyTraced}]];
AppendTo[inputRules,Head[epsilonFund][a__]:>FormTracer`Private`FTxepsFund[groupName,a]];
AppendTo[outputRules,FormTracer`Private`FTxepsFund[groupName,a__]:>Head[epsilonFund][a]];
AppendTo[outputRulesPartiallyTraced,Global`FTxepsFund[groupName,a__]:>Head[epsilonFund][a]];
Return[{inputRules,outputRules,outputRulesTraced,outputRulesPartiallyTraced}];
];


(* ::Input::Initialization:: *)
getGroupNames[groups_List]:=Table[If[Head[groupName]===List,First[groupName],groupName],{groupName,groups[[All,2]]}];

getShortGroupNames[groups_List]:=Module[{n=1,groupNames=ToString/@getGroupNames[groups]},
While[Not[DuplicateFreeQ[StringTake[#,Min[n,StringLength[#]]]&/@groupNames]],n++];
Return[StringTake[#,Min[n,StringLength[#]]]&/@groupNames];
];

getGroupConstantNameRules[groupNaming_,shortGroupName_String]:=Module[{numberOfSpecialNames,specialNames,standardNames,allNames},
numberOfSpecialNames=If[Head[groupNaming]===List,Length[groupNaming]-1,0];
specialNames=If[numberOfSpecialNames>0,Take[groupNaming,-numberOfSpecialNames],{}];
standardNames=ToExpression[StringJoin[#,shortGroupName]]&/@Take[ToString/@formColorPackageExtVars,-Length[formColorPackageExtVars]+numberOfSpecialNames];
allNames=Join[specialNames,standardNames];
Return[Table[formColorPackageExtVars[[i]]->allNames[[i]],{i,Length@formColorPackageExtVars}]];
];

getGroupConstantNames[group_List,shortGroupName_String]:=Module[{groupTemplate,groupNameRules},
groupTemplate=FirstCase[formColorPackageGroupTemplates,{First[group],defValues_,algorithm_}:>defValues];
groupNameRules=getGroupConstantNameRules[group[[2]],shortGroupName];
Return[groupTemplate//.groupNameRules];
];

getGroupTracingAlgorithms[group_List]:=formColorPackageTracingAlgorithms[[FirstCase[formColorPackageGroupTemplates,{First[group],defValues_,algorithm_}:>algorithm]]];

getFormPostGroupRenamingRules[groupConstants_List,shortGroupName_String,groupType_]:="Multiply replace_("~~stringList[toGenericFormString/@Riffle[formColorPackageExtVars,groupConstants]]~~");
"~~If[FirstCase[formColorPackageGroupTemplates,{groupType,defValues_,algorithm_}:>algorithm]==1,"*replace possible color package remnants
#do i = 1, "~~ToString[grpvecsymreplorder]~~"
	Multiply replace_(cOlpR`i',"~~prefixColorPackagegrpvecsym~~shortGroupName~~"R`i',cOlpA`i',"~~prefixColorPackagegrpvecsym~~shortGroupName~~"A`i');
#enddo",""];

getFormGenericDReplacementRules[groupType_]:=If[FirstCase[formColorPackageGroupTemplates,{groupType,defValues_,algorithm_}:>algorithm]==1,"id "~~prefixColorPackagegrpvecsym~~"1?."~~prefixColorPackagegrpvecsym~~"2?="~~prefixColorPackageGenericD~~postfixColorPackagesp~~"("~~prefixColorPackagegrpvecsym~~"1,"~~prefixColorPackagegrpvecsym~~"2);
"~~stringLines[Map["id "~~#~~"(?"~~prefixColorPackagegrpvecsym~~")="~~prefixColorPackageGenericD~~#~~"("~~prefixColorPackagegrpvecsym~~");"&,formColorPackageGenericD]],""];

getFormPreGroupTraceIdentities[shortGroupName_String,groupType_]:="";

getFormPostGroupTensorRenamingRules[groupName_String,shortGroupName_String]:="
id d_(a"~~shortGroupName~~"1?a"~~shortGroupName~~"Indices,a"~~shortGroupName~~"2?)=FTxdeltaAdj("~~groupName~~",a"~~shortGroupName~~"1,a"~~shortGroupName~~"2);
id d_(f"~~shortGroupName~~"1?f"~~shortGroupName~~"Indices,f"~~shortGroupName~~"2?)=FTxdeltaFund("~~groupName~~",f"~~shortGroupName~~"1,f"~~shortGroupName~~"2);
id FTxeps(a"~~shortGroupName~~"1?a"~~shortGroupName~~"Indices,?a"~~shortGroupName~~"2)=FTxepsAdj("~~groupName~~",a"~~shortGroupName~~"1,?a"~~shortGroupName~~"2);
id FTxeps(f"~~shortGroupName~~"1?f"~~shortGroupName~~"Indices,?f"~~shortGroupName~~"2)=FTxepsFund("~~groupName~~",f"~~shortGroupName~~"1,?f"~~shortGroupName~~"2);
id T(f"~~shortGroupName~~"1?,f"~~shortGroupName~~"2?,a"~~shortGroupName~~"1?)=FTxT("~~groupName~~",a"~~shortGroupName~~"1,f"~~shortGroupName~~"1,f"~~shortGroupName~~"2);
id f(a"~~shortGroupName~~"1?,a"~~shortGroupName~~"2?,a"~~shortGroupName~~"3?)=FTxF("~~groupName~~",a"~~shortGroupName~~"1,a"~~shortGroupName~~"2,a"~~shortGroupName~~"3);
";



(* ::Input::Initialization:: *)
ClearGroupTensors[]:=Module[{},
prefixListIndices=prefixListLorentzDirac;
groupTypes={};
groupNames={};
shortGroupNames={};
groupConstantsTable={};
dimGroupVars={};
generateDimensionReplRules[];
groupTracingAlgorithms={};
formPreGroupTraceIdentities={};
formPostGroupRenamingRules={};
formGenericDReplacementRules={};
formPostGroupTensorRenamingRules={};
groupTensorsList={};
groupTensorReplacementRulesInput={};
groupTensorReplacementRulesOutput={};
groupTensorReplacementRulesOutputTraced={};
groupTensorReplacementRulesOutputPartiallyTraced={};
];

DefineGroupTensors[{}]:=ClearGroupTensors[];
DefineGroupTensors[{{}}]:=ClearGroupTensors[];
DefineGroupTensors[groups__]:=DefineGroupTensors[List[groups]]
DefineGroupTensors[groups_List/;Head[First[groups]]==List]:=Module[{replacementRules},
(*sanity check before anything is changed*)
If[Not[DuplicateFreeQ[getGroupNames[groups]]],Message[DefineGroupTensors::duplicategroupnames];Abort[];];
If[AnyTrue[groups[[All,1]],Not@MemberQ[formColorPackageGroupTemplates[[All,1]], #]&],Message[DefineGroupTensors::templatemissing];Abort[];];

(* Initializing group and group constant names *)
Quiet[Check[
groupTypes=groups[[All,1]];
groupNames=getGroupNames[groups];
shortGroupNames=getShortGroupNames[groups];
groupConstantsTable=Table[getGroupConstantNames[groups[[i]],shortGroupNames[[i]]],{i,Length[groups]}];
dimGroupVars=Variables[groupConstantsTable];
generateDimensionReplRules[];
groupTracingAlgorithms=getGroupTracingAlgorithms/@groups;
prefixListIndices=Join[prefixListLorentzDirac,Map[StringJoin["a",#]&,(ToString/@shortGroupNames)],Map[StringJoin["f",#]&,(ToString/@shortGroupNames)]];
formPreGroupTraceIdentities=Table[getFormPreGroupTraceIdentities[ToString@shortGroupNames[[iGroup]],groupTypes[[iGroup]]],{iGroup,Length@groupNames}];
formPostGroupRenamingRules=Table[getFormPostGroupRenamingRules[groupConstantsTable[[iGroup]],ToString@shortGroupNames[[iGroup]],groupTypes[[iGroup]]],{iGroup,Length@groupNames}];
formGenericDReplacementRules=getFormGenericDReplacementRules/@groupTypes;
formPostGroupTensorRenamingRules=Table[getFormPostGroupTensorRenamingRules[ToString@groupNames[[iGroup]],ToString@shortGroupNames[[iGroup]]],{iGroup,Length@groupNames}];
(* Initializing group tensor replacement rules *)
groupTensorsList=getGroupTensors/@groupNames;
replacementRules=getGroupTensorRules/@groups;
,Message[DefineGroupTensors::badarg]],{Take::take,Part::partw,General::stop}];

groupTensorReplacementRulesInput=Dispatch[Flatten[replacementRules[[All,1]]]];
groupTensorReplacementRulesOutput=Dispatch[Flatten[replacementRules[[All,2]]]];
groupTensorReplacementRulesOutputTraced=Dispatch[Flatten[replacementRules[[All,3]]]];
groupTensorReplacementRulesOutputPartiallyTraced=Dispatch[Flatten[replacementRules[[All,4]]]];
];

ShowGroupTemplates[]:=TableForm[Map[Join[#[[2]],{formColorPackageTracingAlgorithms[[#[[3]],1]]~~"("~~formColorPackageTracingAlgorithms[[#[[3]],2]]~~")"}]&,formColorPackageGroupTemplates],TableHeadings->{formColorPackageGroupTemplates[[All,1]],Join[formColorPackageExtVars,{"algorithm(header)"}]},TableSpacing->{3, 3}];

ShowGroupConstants[]:=If[Length[groupNames]===0,Message[ShowGroupConstants::nogroups];,
TableForm[Flatten/@Partition[Riffle[groupTypes,groupConstantsTable],2],TableSpacing->{3, 3},
TableHeadings->{#[[1]]<>"("<>#[[2]]<>")"&/@Partition[ToString/@Riffle[groupNames,shortGroupNames],2],Join[{"type"},formColorPackageExtVars]}]
];


(* ::Input::Initialization:: *)
DefineFormAutoDeclareFunctions[vars___]:=DefineFormAutoDeclareFunctions[List[vars]];
DefineFormAutoDeclareFunctions[vars_List]:=formCFunctionAutoDeclareList=Union[DeleteDuplicates[ToString/@vars],formCFunctionAutoDeclareListBasic];

getSynonymList[symbols_List,genericName_String]:=Map[{#,Unique[genericName]}&,symbols];

DefineExtraVars[vars___]:=DefineExtraVars[List[vars]];
DefineExtraVars[vars_List]:=Module[{extraFormVarsListExport},
(* all extra vars are replaced if result is imported back to Mathematica *)
extraFormVarsList=getSynonymList[DeleteDuplicates[vars],extraFormVarPrefix];
extraFormVarsListInputConversion=Dispatch[Map[#[[1]]->#[[2]]&,extraFormVarsList]];
extraFormVarsListOutputConversion=Dispatch[Map[#[[2]]->#[[1]]&,extraFormVarsList]];
(* only the variables internally used by FORM are replaced if the result is exported to file *)
extraFormVarsListExportDeclare=Complement[ToString/@extraFormVarsList[[All,1]],forbiddenFormVars];(*vars that have to be declared*)
extraFormVarsListExport=Select[extraFormVarsList,MemberQ[forbiddenFormVars,ToString[First[#]]]&];(*(internally used) vars that have to be replaced*)
extraFormVarsListInputConversionExport=Dispatch[Map[#[[1]]->#[[2]]&,extraFormVarsListExport]];
extraFormVarsListOutputConversionExport=If[Length[extraFormVarsListExport]===0,"",
stringLines[Map["id "<>ToString[#[[2]]]<>"="<>ToString[#[[1]]]<>";"&,extraFormVarsListExport]]
];
Return[extraFormVarsList[[All,1]]];
];

AddExtraVars[vars__]:=AddExtraVars[List[vars]];
AddExtraVars[vars_List]:=DefineExtraVars[Union[extraFormVarsList[[All,1]],vars]];

GetExtraVars[]:=extraFormVarsList[[All,1]];
GetExtraVarsSynonyms[]:=extraFormVarsList;

ClearExtraVars[]:=Module[{},
extraFormVarsList={};
extraFormVarsListInputConversion={};
extraFormVarsListOutputConversion={};
];


(* ::Input::Initialization:: *)
replaceMomentaAndIndicesInExpression[momentaFrom_List,indicesFrom_List,expression_,momentaToNameStrings_List,indicesToNameStrings_List]:=Module[{replacementRules},
replacementRules=Join[(* Replace the provided momenta and indices in the expression. *)
Table[momentaFrom[[i]]->ToExpression[momentaToNameStrings[[i]]],{i,Length@momentaFrom}],
Table[indicesFrom[[i]]->ToExpression[indicesToNameStrings[[i]]],{i,Length@indicesFrom}]
];
Return[expression/.replacementRules];
];


(* ::Input::Initialization:: *)
addWildcardMarkersInString[wildcardArguments_List,stringExpression_String,wildcardMarker_String:"?"]:=Module[{RenamingRules},
(* Add "wildcardMarker" after the arguments provided every time they occur in the string.*)RenamingRules=Reverse[SortBy[Table[wildcardArguments[[i]]->wildcardArguments[[i]]<>wildcardMarker,{i,Length@wildcardArguments}],Length]];Return[StringReplace[stringExpression,RenamingRules]];
];


(* ::Input::Initialization:: *)
getFormIdentity[{lhs_,rhs_},momentaName_String:prefixListLorentzDirac[[1]],indicesName_String:prefixListLorentzDirac[[2]]]:=getFormIdentity[{momentumFromExpr[lhs],lorentzFromExpr[lhs],lhs,rhs},momentaName,indicesName];
getFormIdentity[{momenta_List,indices_List,lhs_,rhs_},momentaName_String:prefixListLorentzDirac[[1]],indicesName_String:prefixListLorentzDirac[[2]]]:=Module[{left,right,momentumNames,indexNames},
(* Replace the momenta and indices provided with "momentaName"i and "indicesName"i *)
momentumNames=Table[momentaName<>ToString[i],{i,Length@momenta}];
indexNames=Table[indicesName<>ToString[i],{i,Length@indices}];
right=replaceMomentaAndIndicesInExpression[momenta,indices,rhs,momentumNames,indexNames];left=replaceMomentaAndIndicesInExpression[momenta,indices,lhs,momentumNames,indexNames];(* Add a wildcard marker "?" after each momentum and index in the lhs string *)
left=addWildcardMarkersInString[Join[momentumNames,indexNames],toFormStringLorentz[left],"?"];
(* Return a FORM string identifying a tensor structure with wildcard arguments on the lhs with an expression on the rhs. *)
Return["id "<>left<>"="<>toFormStringLorentz[right]<>";"];
];


(* ::Input::Initialization:: *)
getFormIdentityFromFile[{lhs_,importPath_String}]:=getFormIdentityFromFile[{momentumFromExpr[lhs],lorentzFromExpr[lhs],lhs,importPath}];
getFormIdentityFromFile[{momenta_List,indices_List,lhs_,importPath_String}]:= Module[{short,identityString,declarationsString},
(* Bring the lhs into FORM format. *)
short=toFormStringLorentz[replaceMomentaAndIndicesInExpression[momenta,indices,lhs,ToString/@momenta,ToString/@indices]];short=addWildcardMarkersInString[Join[ToString/@momenta,ToString/@indices],short,"?"];(* Create a FORM identity string. *)
identityString="id "<>short<>" = \n"<>"#include "<>importPath<>"\n;\n.sort\n\n";
(* Create a FORM string declaring the momenta as vectors and indices as indices. *)
declarationsString="Vector "<>stringList@momenta<>";\nIndex "<>stringList@indices<>";\n";
Return[declarationsString<>identityString];
];


(* ::Input::Initialization:: *)
getIndicesRuleFromCombinedLorentzTensor[combinedTensor_]:=barrepl[combinedTensor[[3]],Join[combinedTensor[[1]],combinedTensor[[2]]]]:>Evaluate[combinedTensor[[2]]];
getMomentumRuleFromCombinedLorentzTensor[combinedTensor_]:=barrepl[combinedTensor[[3]],Join[combinedTensor[[1]],combinedTensor[[2]]]]:>Evaluate[combinedTensor[[1]]];


(* ::Input::Initialization:: *)
addbarPlus[s_Symbol]:=ToExpression[ToString[s]<>"_Plus"];


(* ::Input::Initialization:: *)
barreplPlus[s_,vars_List,i_Integer]:=s/.Table[If[i==j,vars[[j]]->addbarPlus[vars[[j]]],vars[[j]]->addbar[vars[[j]]]],{j,1,Length[vars]}];


(* ::Input::Initialization:: *)
getCombinedMomentumReplForCombinedTensor[combinedTensor_]:=Module[{ms},
Table[barreplPlus[combinedTensor[[3]],Join[combinedTensor[[1]],combinedTensor[[2]]],i]:>Evaluate[(combinedTensor[[3]]/.combinedTensor[[1]][[i]]->ms[combinedTensor[[1]][[i]]])],{i,Length[combinedTensor[[1]]]}]/.ms->momentumSum];


(* ::Input::Initialization:: *)
lorentzTensorIdentitiesInputCache={};

ClearLorentzTensorIdentities[]:=Module[{},
lorentzTensorIdentitiesInputCache={};
formLorentzTensorIdentities={};
];

AddLorentzTensorIdentity[identity_List]:=Module[{},
If[getClosedLorentzIndices[Last[identity]]=!={},Message[AddLorentzTensorIdentity::closedindices];Abort[];];
If[spinorFromExpr[Last[identity]]=!={},Message[AddLorentzTensorIdentity::diracindices];Abort[];];
AppendTo[lorentzTensorIdentitiesInputCache,identity];
AppendTo[formLorentzTensorIdentities,getFormIdentity[convertInput[identity]]];
];

DefineLorentzTensorIdentities[identities_List]:=Module[{},
ClearLorentzTensorIdentities[];
Do[AddLorentzTensorIdentity[identity],{identity,identities}];
];


(* ::Input::Initialization:: *)
combinedLorentzTensorInputCache={};

ClearCombinedLorentzTensors[]:=Module[{},
combinedTensorNames={};
combinedTensorIdentities={};
combinedTensorSquaresReplRules={};
combinedLorentzTensorInputCache={};
lorentzFromExprRules=basicLorentzFromExprRules;
momentumFromExprRules=basicMomentumFromExprRules;
combinedMomentumRepl=basicCombinedMomentumRepl;
];

AddCombinedLorentzTensor[combinedTensorArg_List]:=Module[{combinedTensor,combinedTensorName,explicitTensor=convertInput[Last[combinedTensorArg]],tmpLorentzTensorIdentitiesInputCache=lorentzTensorIdentitiesInputCache},
If[lorentzTensorReplacementRulesInput==={},Message[AddCombinedLorentzTensor::missingnotation];Abort[];];
If[getClosedLorentzIndices[explicitTensor]=!={},Message[AddCombinedLorentzTensor::closedindices];Abort[];];
If[spinorFromExpr[explicitTensor]=!={},Message[AddCombinedLorentzTensor::diracindices];Abort[];];
If[Or@@(Head[#]===Plus&/@momentumFromExpr[explicitTensor]),Message[AddCombinedLorentzTensor::momentumsums];Abort[];];
If[checkAllTensorSums[explicitTensor]===False,Abort[];];
If[MemberQ[combinedLorentzTensorInputCache,combinedTensorArg],Message[AddCombinedLorentzTensor::duplicate];Abort[];];

(*combinedTensor = {momenta list, index list, abbreviation, explicit tensor*)
combinedTensor=Switch[Length[combinedTensorArg],
2,Join[{momentumFromExpr[explicitTensor],lorentzFromExpr[explicitTensor]},combinedTensorArg],
3,Join[{momentumFromExpr[explicitTensor]},combinedTensorArg],
4,combinedTensorArg,
_,Message[AddCombinedLorentzTensor::badarg];Abort[];
];

combinedTensorName=Head[combinedTensor[[3]]];
AppendTo[combinedLorentzTensorInputCache,combinedTensorArg];
AppendTo[combinedTensorNames,combinedTensorName];
AppendTo[lorentzTensors,combinedTensorName[___]];
AppendTo[lorentzFromExprRules,getIndicesRuleFromCombinedLorentzTensor[combinedTensor]];
AppendTo[momentumFromExprRules,getMomentumRuleFromCombinedLorentzTensor[combinedTensor]];
Do[AppendTo[combinedMomentumRepl,rule],{rule,getCombinedMomentumReplForCombinedTensor[combinedTensor]}];
(* PrependTo is used here since explicit expressions must be inserted in reverse order if they depend on each other. *)
PrependTo[combinedTensorIdentities,
If[Head[Last[combinedTensor]]=!=String,
getFormIdentity[convertInput[combinedTensor]],
getFormIdentityFromFile[combinedTensor]
]];
ClearLorentzTensorIdentities[];
If[Head[Last[combinedTensor]]=!=String,
AppendTo[combinedTensorSquaresReplRules,barrepl[combinedTensor[[3]]^2,Flatten@Take[combinedTensor,2]]:>Evaluate[convertInput[FormTrace[explicitTensor^2]]]];
];
DefineLorentzTensorIdentities[tmpLorentzTensorIdentitiesInputCache];
];

DefineCombinedLorentzTensors[combinedTensors_List]:=Module[{},
ClearCombinedLorentzTensors[];
Do[AddCombinedLorentzTensor[combinedTensor],{combinedTensor,combinedTensors}];
];


(* ::Input::Initialization:: *)
isTensor[expr_]:=Or@@Join[{Not[FreeQ[expr,Alternatives@@lorentzTensors]]},Map[Not[FreeQ[expr,Alternatives@@#]]&,groupTensorsList]];
removeSquaredTensorSums={Power[a_Plus,n_/;n!=2]:>pow[a,n],Power[a_Plus,2]:>If[isTensor[a],Expand[a^2],pow[a,2]]};

removeSquaredTensorsRulesT0={
FTxvec[p_,mu_]^2/;Not[IntegerQ[mu]]:>FTxsp[p,p],
FTxdeltaLorentz[mu_,mu_]:>If[IntegerQ[mu],1,First[lorentzDimensions]],
FTxdeltaLorentz[mu_,nu_]^2/;mu=!=nu:>If[IntegerQ[mu]&&IntegerQ[nu],0,If[IntegerQ[mu]||IntegerQ[nu],1,First[lorentzDimensions]]],
FTxepsLorentz[mu_,nu_,rho___]^2:>-FTxepsLorentz[nu,mu,rho]*FTxepsLorentz[mu,nu,rho],
FTxdeltaDirac[i_,i_]:>If[IntegerQ[i],1,Last[lorentzDimensions]],
FTxdeltaDirac[i_,j_]^2/;i=!=j:>If[IntegerQ[i]&&IntegerQ[j],0,If[IntegerQ[i]||IntegerQ[j],1,Last[lorentzDimensions]]],
FTxdeltaAdj[group_,a_,a_]:>If[IntegerQ[a],1,groupConstantsTable[[First[FirstPosition[groupNames,group]],3]]],
FTxdeltaAdj[group_,a_,b_]^2/;a=!=b:>If[IntegerQ[a]&&IntegerQ[b],0,If[IntegerQ[a]||IntegerQ[b],1,groupConstantsTable[[First[FirstPosition[groupNames,group]],3]]]],
FTxdeltaFund[group_,a_,a_]:>If[IntegerQ[a],1,groupConstantsTable[[First[FirstPosition[groupNames,group]],1]]],
FTxdeltaFund[group_,a_,b_]^2/;a=!=b:>If[IntegerQ[a]&&IntegerQ[b],0,If[IntegerQ[a]||IntegerQ[b],1,groupConstantsTable[[First[FirstPosition[groupNames,group]],1]]]],
FTxepsAdj[group_,a_,b_,cc___]^2:>-FTxepsAdj[group,b,a,cc]*FTxepsAdj[group,a,b,cc],
FTxepsFund[group_,a_,b_,cc___]^2:>-FTxepsFund[group,b,a,cc]*FTxepsFund[group,a,b,cc],
FTxF[group_,a_,b_,c_]^2:>-FTxF[group,b,a,c]*FTxF[group,a,b,c]
};
removeSquaredTensorsRulesT={
FTxvecs[p_,mu_]^2/;Not[IntegerQ[mu]]:>FTxsps[p,p]
};
removeSquaredTensorsRules=removeSquaredTensorsRulesT0;

(*squared sums must be removed in advance*)
removeSquaredTensors[expr_]:=expr/.removeSquaredTensorSums/.removeSquaredTensorsRules/.combinedTensorSquaresReplRules;


(* ::Input::Initialization:: *)
(* implements support for shorthand notation for gamma matrices*)
expandGammaMatrices[lor_,spi___]:=Module[{lorList=lor(*/.lorentzTensorReplacementRulesInput*),spiList=List[spi],res},
If[Length[spiList]===0,spiList=With[{spiDummy=Unique[spiDummyPrefix]},{spiDummy,spiDummy}]];
res=FTxgamma@@Join[lorList,spiList];
(*expand momenta*)
res=res//.FTxgamma[a___,FTxvec[p_],b___]:>With[{lorDummy=Unique[lorDummyPrefix]},FTxvec[p,lorDummy]FTxgamma[a,lorDummy,b]];
If[finiteTenabled,res=res//.FTxgamma[a___,FTxvecs[p_],b___]:>With[{lorDummy=Unique[lorDummyPrefix]},FTxvecs[p,lorDummy]FTxgamma[a,lorDummy,b]];];
(*expand gamma matrices*)
res=res//.FTxgamma[a___,b_,c_,i_,j_]:>With[{spiDummy=Unique[spiDummyPrefix]},FTxgamma[a,b,i,spiDummy]FTxgamma[c,spiDummy,j]];
(*convert gamma 5 matrices to FTxgamma5 symbols*)
res=res/.{FTxgamma[5,spi1_,spi2_]:>FTxgamma5[spi1,spi2],FTxgamma[FTxgamma5,spi1_,spi2_]:>FTxgamma5[spi1,spi2]};
Return[res];
];


(* ::Input::Initialization:: *)
convertInput[input_,replaceExtraAllVars_:True]:=Module[{res,check=True},
If[lorentzTensorReplacementRulesInput==={}&&groupTensorReplacementRulesInput==={},Message[convertInput::missingnotation];Abort[];];
res=removeSquaredTensors[input//.lorentzTensorReplacementRulesInput/.groupTensorReplacementRulesInput/.If[replaceExtraAllVars,extraFormVarsListInputConversion,extraFormVarsListInputConversionExport]];
res=(res/.{FTxgamma[FTxvec[p_],spi___]:>FTxgamma[{FTxvec[p]},spi],FTxgamma[FTxvecs[p_],spi___]:>FTxgamma[{FTxvecs[p]},spi]})/.FTxgamma[lor_List,spi___]:>expandGammaMatrices[lor,spi];
If[checkTensorSums||debuggingMode,check=checkAllTensorSums[res];];
Return[If[check,res,Null]];
]


(* ::Input::Initialization:: *)
ConvertInput[input_,replaceExtraAllVars_:False]:=convertInput[input,replaceExtraAllVars];


(* ::Input::Initialization:: *)
enableFiniteT[yesno_]:=Module[{},
If[yesno,
basicLorentzFromExprRules=Join[basicLorentzFromExprRulesT0,basicLorentzFromExprRulesT];
lorentzFromExprRules=Union[lorentzFromExprRules,basicLorentzFromExprRulesT];,
basicLorentzFromExprRules=basicLorentzFromExprRulesT0;
lorentzFromExprRules=Complement[lorentzFromExprRules,basicLorentzFromExprRulesT];
];
If[yesno,
basicMomentumFromExprRules=Join[basicMomentumFromExprRulesT0,basicMomentumFromExprRulesT];
momentumFromExprRules=Union[momentumFromExprRules,basicMomentumFromExprRulesT];,
basicMomentumFromExprRules=basicMomentumFromExprRulesT0;
momentumFromExprRules=Complement[momentumFromExprRules,basicMomentumFromExprRulesT];
];
If[yesno,
basicLorentzTensors=Join[basicLorentzTensorsT0,basicLorentzTensorsT];
lorentzTensors=Union[lorentzTensors,basicLorentzTensorsT];,
basicLorentzTensors=basicLorentzTensorsT0;
lorentzTensors=Complement[lorentzTensors,basicLorentzTensorsT];
];
If[yesno,
removeSquaredTensorsRules=Join[removeSquaredTensorsRulesT0,removeSquaredTensorsRulesT],
removeSquaredTensorsRules=removeSquaredTensorsRulesT0
];
If[yesno,
basicCombinedMomentumRepl=Join[basicCombinedMomentumReplT0,basicCombinedMomentumReplT];
combinedMomentumRepl=Union[combinedMomentumRepl,basicCombinedMomentumReplT];,
basicCombinedMomentumRepl=basicCombinedMomentumReplT0;
combinedMomentumRepl=Complement[combinedMomentumRepl,basicCombinedMomentumReplT];
];
finiteTenabled=yesno;
Return[finiteTenabled];
];


(* ::Input::Initialization:: *)
(*FORM names dummies on a term by term basis. Thus, the same dummy names can be used for different index types, which is a problem for FormTracer. Here we rename the dummy indices to solve that problem.*)

getDummy[group_,tempDummy_,typePrefix_]:=ToExpression[typePrefix<>ToString[group]<>"Dummy"<>ToString[tempDummy]]
getAdjDummy[group_,tempDummy_]:=getDummy[group,tempDummy,adjGroupDummyPrefix]
getFundDummy[group_,tempDummy_]:=getDummy[group,tempDummy,fundGroupDummyPrefix]

getLorDummy[tempDummy_]:=ToExpression[lorDummyPrefixFORM<>ToString[tempDummy]]
getSpiDummy[tempDummy_]:=ToExpression[spiDummyPrefixFORM<>ToString[tempDummy]]

groupDummyReplacementFORM={
Global`FTxdeltaAdj[group_,tempPartialTraceDummy[a_],b_]:>Global`FTxdeltaAdj[group,getAdjDummy[group,a],b],
Global`FTxdeltaAdj[group_,a_,tempPartialTraceDummy[b_]]:>Global`FTxdeltaAdj[group,a,getAdjDummy[group,b]],

Global`FTxdeltaFund[group_,tempPartialTraceDummy[i_],j_]:>Global`FTxdeltaFund[group,getFundDummy[group,i],j],
Global`FTxdeltaFund[group_,i_,tempPartialTraceDummy[j_]]:>Global`FTxdeltaFund[group,i,getFundDummy[group,j]],

Global`FTxF[group_,a___,tempPartialTraceDummy[b_],c___]:>Global`FTxF[group,a,getAdjDummy[group,b],c],

Global`FTxT[group_,tempPartialTraceDummy[a_],i_,j_]:>Global`FTxT[group,getAdjDummy[group,a],i,j],
Global`FTxT[group_,a_,tempPartialTraceDummy[i_],j_]:>Global`FTxT[group,a,getFundDummy[group,i],j],
Global`FTxT[group_,a_,i_,tempPartialTraceDummy[j_]]:>Global`FTxT[group,a,i,getFundDummy[group,j]],

Global`FTxepsAdj[group_,a___,tempPartialTraceDummy[b_],c___]:>Global`FTxepsAdj[group,a,getAdjDummy[group,b],c],
Global`FTxepsFund[group_,i___,tempPartialTraceDummy[j_],k___]:>Global`FTxepsFund[group,i,getFundDummy[group,j],k]
};

lorentzDummyReplacementFORM={
Global`FTxdeltaLorentz[tempPartialTraceDummy[mu_],nu_]:>Global`FTxdeltaLorentz[getLorDummy[mu],nu],
Global`FTxdeltaLorentz[mu_,tempPartialTraceDummy[nu_]]:>Global`FTxdeltaLorentz[mu,getLorDummy[nu]],

Global`FTxdeltaDirac[tempPartialTraceDummy[i_],j_]:>Global`FTxdeltaDirac[getSpiDummy[i],j],
Global`FTxdeltaDirac[i_,tempPartialTraceDummy[j_]]:>Global`FTxdeltaDirac[i,getSpiDummy[j]],

Global`FTxvec[p_,tempPartialTraceDummy[mu_]]:>Global`FTxvec[p,getLorDummy[mu]],
Global`FTxvecs[p_,tempPartialTraceDummy[mu_]]:>Global`FTxvecs[p,getLorDummy[mu]],

Global`FTxgamma[tempPartialTraceDummy[mu_],i_,j_]:>Global`FTxgamma[getLorDummy[mu],i,j],
Global`FTxgamma[{mu___,tempPartialTraceDummy[nu_],rho___},i_,j_]:>Global`FTxgamma[{mu,getLorDummy[nu],rho},i,j],
Global`FTxgamma[mu_,tempPartialTraceDummy[i_],j_]:>Global`FTxgamma[mu,getSpiDummy[i],j],
Global`FTxgamma[mu_,i_,tempPartialTraceDummy[j_]]:>Global`FTxgamma[mu,i,getSpiDummy[j]],

Global`FTxgamma5[tempPartialTraceDummy[i_],j_]:>Global`FTxgamma5[getSpiDummy[i],j],
Global`FTxgamma5[i_,tempPartialTraceDummy[j_]]:>Global`FTxgamma5[i,getSpiDummy[j]],

Global`FTxepsLorentz[mu___,tempPartialTraceDummy[nu_],rho___]:>Global`FTxepsLorentz[mu,getLorDummy[nu],rho]
};


(* ::Input::Initialization:: *)
createOutputReplacementList[repl_List]:=Flatten[Join[Map[If[Length[#[[1]]]>0,generateReplList[#[[2]],#[[1]]],{}]&,repl]]];

convertOutput[output_,repl_List:{}]:=output/.createOutputReplacementList[repl]/.lorentzTensorReplacementRulesOutput/.groupTensorReplacementRulesOutput/.extraFormVarsListOutputConversion/.pow[x_,y_]:>x^y;
convertTracedOutput[output_,repl_List:{}]:=output/.createOutputReplacementList[repl]/.lorentzTensorReplacementRulesOutputTraced/.groupTensorReplacementRulesOutputTraced/.extraFormVarsListOutputConversion/.Global`pow[x_,y_]:>x^y;
convertPartiallyTracedOutput[output_,repl_List:{}]:=output//.groupDummyReplacementFORM//.lorentzDummyReplacementFORM/.createOutputReplacementList[repl]//.lorentzTensorReplacementRulesOutputPartiallyTraced/.groupTensorReplacementRulesOutputPartiallyTraced/.extraFormVarsListOutputConversion/.Global`pow[x_,y_]:>x^y;


(* ::Input::Initialization:: *)
(* extracts variables from expression from rules *)
variablesFromExprRules[expr_,rules_List]:=Select[Map[Cases[{expr},#,Infinity]&,rules]//Flatten//DeleteDuplicates,Not[NumericQ[#]]&];

(* group indices from expr *)
getFundGroupIndices[expr_,group_]:=variablesFromExprRules[expr,fundIndicesFromExprRules[group]];
getAdjGroupIndices[expr_,group_]:=variablesFromExprRules[expr,adjIndicesFromExprRules[group]];
(* Lorentz indices from expr *)
lorentzFromExpr[expr_]:=variablesFromExprRules[expr,lorentzFromExprRules];
(* Dirac indices from expr *)
spinorFromExpr[expr_]:=variablesFromExprRules[expr,spinorFromExprRules];

(* private open indices extraction functions *)
getOpenIndices[expr_List,indicesFromExprRules_List]:=Module[{filteredExpr,indexList,openIndexList={}},
filteredExpr=Select[expr,Head[#]=!=Power&];
indexList=Flatten[Map[Cases[filteredExpr,#,Infinity]&,indicesFromExprRules]];
Do[If[Count[indexList,index]!=2&&Not[IntegerQ[index]],AppendTo[openIndexList,index];];,{index,Union[indexList]}];
Return[openIndexList];
];
(* assuming that expr is well-defined we exploit that terms of sums must have the same indices; this is crucial for the performance in the case of large expressions *)
getOpenIndices[expr_Times,indicesFromExprRules_List]:=getOpenIndices[List@@(expr//.Plus[firstTerm_,__]:>firstTerm//removeSquaredTensors),indicesFromExprRules];
getOpenIndices[expr_Plus,indicesFromExprRules_List]:=getOpenIndices[expr//.Plus[firstTerm_,__]:>firstTerm//removeSquaredTensors,indicesFromExprRules];
getOpenIndices[expr_,indicesFromExprRules_List]:=getOpenIndices[{expr//.Plus[firstTerm_,__]:>firstTerm//removeSquaredTensors},indicesFromExprRules];
getOpenIndices[expr_Power,indicesFromExprRules_List]:={};


(* private indices functions *)
getOpenLorentzIndices[expr_]:=getOpenIndices[expr,lorentzFromExprRules];
getOpenLorentzIndices[expr_List]:=getOpenLorentzIndices/@expr;
getOpenDiracIndices[expr_]:=getOpenIndices[expr,spinorFromExprRules];
getOpenDiracIndices[expr_List]:=getOpenDiracIndices/@expr;

getOpenFundGroupIndices[expr_,group_]:=getOpenIndices[expr,fundIndicesFromExprRules[group]];
getOpenFundGroupIndices[expr_List,group_]:=Map[getOpenFundGroupIndices[#,group]&,expr];
getOpenAdjGroupIndices[expr_,group_]:=getOpenIndices[expr,adjIndicesFromExprRules[group]];
getOpenAdjGroupIndices[expr_List,group_]:=Map[getOpenAdjGroupIndices[#,group]&,expr];

getOpenIndices[expr_List]:=getOpenIndices/@expr;
getOpenIndices[expr_]:=Module[{openFundIndices,openAdjIndices},
openFundIndices=Flatten[Map[getOpenFundGroupIndices[expr,#]&,groupNames]];
openAdjIndices=Flatten[Map[getOpenAdjGroupIndices[expr,#]&,groupNames]];
Return[Join[getOpenLorentzIndices[expr],getOpenDiracIndices[expr],openFundIndices,openAdjIndices]];
];


getClosedLorentzIndices[expr_]:=Complement[lorentzFromExpr[expr],getOpenLorentzIndices[expr]];
getClosedDiracIndices[expr_]:=Complement[spinorFromExpr[expr],getOpenDiracIndices[expr]];

getClosedFundGroupIndices[expr_,group_]:=Complement[getFundGroupIndices[expr,group],getOpenFundGroupIndices[expr,group]];
getClosedAdjGroupIndices[expr_,group_]:=Complement[getAdjGroupIndices[expr,group],getOpenAdjGroupIndices[expr,group]];


getClosedIndices[expr_List]:=getClosedIndices/@expr;
getClosedIndices[expr_]:=Module[{closedFundIndices,closedAdjIndices},
closedFundIndices=Flatten[Map[getClosedFundGroupIndices[expr,#]&,groupNames]];
closedAdjIndices=Flatten[Map[getClosedAdjGroupIndices[expr,#]&,groupNames]];
Return[Join[getClosedLorentzIndices[expr],getClosedDiracIndices[expr],closedFundIndices,closedAdjIndices]];
];


(* ::Input::Initialization:: *)

(* Public indices functions *)
GetLorentzIndices[expr_List]:=GetLorentzIndices/@expr;
GetLorentzIndices[expr_]:=lorentzFromExpr[convertInput[expr]];

GetDiracIndices[expr_List]:=GetDiracIndices/@expr;
GetDiracIndices[expr_]:=spinorFromExpr[convertInput[expr]];


GetFundGroupIndices[expr_]:=If[Length[groupNames]===1,GetFundGroupIndices[expr,First[groupNames]],Message[GetFundGroupIndices::grouparg];]
GetFundGroupIndices[expr_List,group_]:=Map[GetFundGroupIndices[#,group]&,expr];
GetFundGroupIndices[expr_,group_]:=getFundGroupIndices[convertInput[expr],group];

GetAdjGroupIndices[expr_]:=If[Length[groupNames]===1,GetAdjGroupIndices[expr,First[groupNames]],Message[GetAdjGroupIndices::grouparg];]
GetAdjGroupIndices[expr_List,group_]:=Map[GetAdjGroupIndices[#,group]&,expr];
GetAdjGroupIndices[expr_,group_]:=getAdjGroupIndices[convertInput[expr],group];

GetIndices[expr_List]:=GetIndices/@expr;
GetIndices[expr_]:=Module[{fundIndices,adjIndices},
fundIndices=Flatten[Map[GetFundGroupIndices[expr,#]&,groupNames]];
adjIndices=Flatten[Map[GetAdjGroupIndices[expr,#]&,groupNames]];
Return[Join[GetLorentzIndices[expr],GetDiracIndices[expr],fundIndices,adjIndices]];
];


GetOpenIndices[expr_]:=getOpenIndices[convertInput[expr]];

GetOpenLorentzIndices[expr_]:=getOpenLorentzIndices[convertInput[expr]];
GetOpenDiracIndices[expr_]:=getOpenDiracIndices[convertInput[expr]];

GetOpenFundGroupIndices[expr_]:=If[Length[groupNames]===1,GetOpenFundGroupIndices[expr,First[groupNames]],Message[GetOpenFundGroupIndices::grouparg];]
GetOpenFundGroupIndices[expr_,group_]:=getOpenFundGroupIndices[convertInput[expr],group];

GetOpenAdjGroupIndices[expr_]:=If[Length[groupNames]===1,GetOpenAdjGroupIndices[expr,First[groupNames]],Message[GetOpenAdjGroupIndices::grouparg];]
GetOpenAdjGroupIndices[expr_,group_]:=getOpenAdjGroupIndices[convertInput[expr],group];


GetClosedIndices[expr_]:=getClosedIndices[convertInput[expr]];

GetClosedLorentzIndices[expr_List]:=GetClosedLorentzIndices/@expr;
GetClosedLorentzIndices[expr_]:=getClosedLorentzIndices[convertInput[expr]];

GetClosedDiracIndices[expr_List]:=GetClosedDiracIndices/@expr;
GetClosedDiracIndices[expr_]:=getClosedDiracIndices[convertInput[expr]];

GetClosedFundGroupIndices[expr_]:=If[Length[groupNames]===1,GetClosedFundGroupIndices[expr,First[groupNames]],Message[GetClosedFundGroupIndices::grouparg];]
GetClosedFundGroupIndices[expr_List,group_]:=Map[GetClosedFundGroupIndices[#,group]&,expr];
GetClosedFundGroupIndices[expr_,group_]:=getClosedFundGroupIndices[convertInput[expr],group];

GetClosedAdjGroupIndices[expr_]:=If[Length[groupNames]===1,GetClosedAdjGroupIndices[expr,First[groupNames]],Message[GetClosedAdjGroupIndices::grouparg];]
GetClosedAdjGroupIndices[expr_List,group_]:=Map[GetClosedAdjGroupIndices[#,group]&,expr];
GetClosedAdjGroupIndices[expr_,group_]:=getClosedAdjGroupIndices[convertInput[expr],group];


(* ::Input::Initialization:: *)
(* private sum checks functions *)
checkSum[expr_Plus,openIndicesFunction_]:=Module[{openIndicesLists},
openIndicesLists=Sort/@(openIndicesFunction/@Apply[List,expr]);
Return[If[AllTrue[Rest[openIndicesLists],#===First[openIndicesLists]&],True,Message[CheckTensorSums::invalidsum,openIndicesLists];False]];
];
sumsFromExpr[expr_]:=Cases[{expr},Plus[x_,y__]:>Plus[x,y],Infinity];
checkAllSums[expr_,function_]:=And@@Map[checkSum[#,function]&,sumsFromExpr[expr]];

checkLorentzTensorSums[expr_]:=checkAllSums[expr,getOpenLorentzIndices];
checkDiracTensorSums[expr_]:=checkAllSums[expr,getOpenDiracIndices];
checkAdjGroupTensorSums[expr_,group_]:=checkAllSums[expr,getOpenAdjGroupIndices[#,group]&];
checkFundGroupTensorSums[expr_,group_]:=checkAllSums[expr,getOpenFundGroupIndices[#,group]&];

checkAllTensorSums[expr_]:=Module[{lorentzCheck,diracCheck,fundGroupCheck,adjGroupCheck},
lorentzCheck=checkLorentzTensorSums[expr];
diracCheck=checkDiracTensorSums[expr];
fundGroupCheck=And@@Map[checkFundGroupTensorSums[expr,#]&,groupNames];
adjGroupCheck=And@@Map[checkAdjGroupTensorSums[expr,#]&,groupNames];
Return[lorentzCheck&&diracCheck&&fundGroupCheck&&adjGroupCheck];
];

convertInputWithoutSumCheck[expr_]:=Module[{tmpDebuggingMode,tmpCheckTensorSums,convertedExpr},
tmpCheckTensorSums=checkTensorSums;
tmpDebuggingMode=debuggingMode;
checkTensorSums=False;
debuggingMode=False;
convertedExpr=convertInput[expr];
checkTensorSums=tmpCheckTensorSums;
debuggingMode=tmpDebuggingMode;
Return[convertedExpr];
];


(* ::Input::Initialization:: *)
(* public check functions *)
CheckLorentzTensorSums[expr_]:=checkLorentzTensorSums[convertInputWithoutSumCheck[expr]];
CheckDiracTensorSums[expr_]:=checkDiracTensorSums[convertInputWithoutSumCheck[expr]];

CheckFundGroupTensorSums[expr_]:=If[Length[groupNames]==1,CheckFundGroupTensorSums[expr,First[groupNames]],Message[CheckFundGroupTensorSums::grouparg];];
CheckFundGroupTensorSums[expr_,group_]:=checkFundGroupTensorSums[convertInputWithoutSumCheck[expr],group];

CheckAdjGroupTensorSums[expr_]:=If[Length[groupNames]==1,CheckAdjGroupTensorSums[expr,First[groupNames]],Message[CheckAdjGroupTensorSums::grouparg];];
CheckAdjGroupTensorSums[expr_,group_]:=checkAdjGroupTensorSums[convertInputWithoutSumCheck[expr],group];

CheckTensorSums[expr_]:=checkAllTensorSums[convertInputWithoutSumCheck[expr]];


(* ::Input::Initialization:: *)
lorentzTensorProductToSortedLists[term_]:={{term}};
lorentzTensorProductToSortedLists[term_Times]:=Module[{abort,completeDiracTrace,iTensor,openLorentzIndices,openDiracIndices,tmpProduct,tmpProductList,disjointProductsList={},unsortedTensors=List@@term},
abort[]:=Module[{},Message[ExpandLorentzStructures::failedconsistencycheck];Abort[];];

completeDiracTrace[expr_]:=Module[{tmpExpr=expr},
While[Length[openDiracIndices=getOpenDiracIndices[tmpExpr]]>0,
iTensor=Catch[Do[If[MemberQ[getOpenDiracIndices[unsortedTensors[[i]]],Alternatives@@openDiracIndices],Throw[i]];,{i,Length[unsortedTensors]}];Throw[0];];
If[iTensor==0,abort[]];
tmpExpr=tmpExpr*unsortedTensors[[iTensor]];
unsortedTensors=Drop[unsortedTensors,{iTensor}];
];
Return[tmpExpr];
];

While[Length[unsortedTensors]>0,
tmpProduct=First[unsortedTensors];
unsortedTensors=Rest[unsortedTensors];
tmpProductList={completeDiracTrace[tmpProduct]};

While[Length[openLorentzIndices=getOpenLorentzIndices[Times@@tmpProductList]]>0,
iTensor=Catch[Do[If[MemberQ[getOpenLorentzIndices[unsortedTensors[[i]]],Alternatives@@openLorentzIndices],Throw[i]];,{i,Length[unsortedTensors]}];Throw[0];];
If[iTensor==0,abort[]];
tmpProduct=unsortedTensors[[iTensor]];
unsortedTensors=Drop[unsortedTensors,{iTensor}];
AppendTo[tmpProductList,completeDiracTrace[tmpProduct]];
];

AppendTo[disjointProductsList,tmpProductList];
];

(*check the result if in debugging mode*)
If[debuggingMode,If[Apply[Times,disjointProductsList,{0,1}]=!=term,abort[];];];

Return[disjointProductsList];
];


(* ::Input::Initialization:: *)
(* Private function *)
expandLorentzStructures[expr_Plus]:=lorentzTensorProductToSortedLists/@(List@@expr);
expandLorentzStructures[expr_]:={lorentzTensorProductToSortedLists[expr]};

(* Public function *)
ExpandLorentzStructures[expr_]:=convertOutput[expandLorentzStructures[convertInput[expr]]];


(* ::Input::Initialization:: *)
(* This function separates factors in expr. It returns a list of length 2. The first element of that list contains all factors that do not depend on any object in the objects list, the second element all others, i.e. those that do depend on at least one object of the objects list. *)
separateFactors[expr_,alternatives_]:=If[FreeQ[expr,alternatives],{expr,1},{1,expr}];
separateFactors[expr_Times,alternatives_]:=Module[{prefactorList={1},mainList={1}},
Do[
If[FreeQ[factor,alternatives],
AppendTo[prefactorList,factor],
AppendTo[mainList,factor]
]
,{factor,List@@expr}];
Return[{Times@@prefactorList,Times@@mainList}];
];

(* Expands expr but leaves parts that are free of all elements of the expansion list unexpanded. *)
expandIteratively[expr_,expansionList_]:=If[Length[expansionList]===1,
Expand[expr,First[expansionList]],
Expand[expandIteratively[expr,Rest[expansionList]],First[expansionList]]
];


(* ::Input::Initialization:: *)
expandExpr[expr_,tensorLists_List]:=Module[{currentList=First[tensorLists],remainingLists=Rest[tensorLists],expandedExpr,separatedExpr},
If[remainingLists==={},
Return[If[disentangleLorentzStructures,expandLorentzStructures[removeSquaredTensors[expr]],expr]];
];
If[FreeQ[expr,Alternatives@@currentList],
Return[{{1,expandExpr[expr,remainingLists]}}];
];
expandedExpr=expandIteratively[Collect[expandIteratively[expr,currentList],currentList],currentList];
separatedExpr=Map[separateFactors[#,Alternatives@@Flatten[remainingLists]]&,If[Head[expandedExpr]===Plus,List@@expandedExpr,{expandedExpr}]];
Return[Map[{First[#],expandExpr[Last[#],remainingLists]}&,separatedExpr]];
];

expandTerm[term_,tensorLists_]:=Module[{prefactor,main},
{prefactor,main}=separateFactors[term,Alternatives@@Flatten[tensorLists]];
Return[{prefactor,expandExpr[main,tensorLists]}];
];

(* Private function *)
expandTerms[term_]:=expandTerms[{term}];
expandTerms[terms_List]:=Module[{tensorLists},
tensorLists=Append[groupTensorsList,lorentzTensors];
Return[Map[expandTerm[#,tensorLists]&,terms]];
];
(* Public function *)
ExpandTerms[terms_]:=convertOutput[expandTerms[convertInput[terms]]];


(* ::Input::Initialization:: *)
removeSign[expr_Times]:=expr[[2]];
removeSign[expr_Symbol]:=expr;(*for combined tensors*)
removeSign[expr_Plus]:=expr;(*for combined tensors-error message*)

momentumFromExpr[expr_]:=removeSign/@variablesFromExprRules[expr,momentumFromExprRules];

canonicalOrderQ[expr_]:=Module[{exprsym},exprsym=(expr//Expand);If[Head@exprsym===Plus,If[Head@exprsym[[1]]===Times,Sign[exprsym[[1,1]]]==1,True],If[Head@exprsym===Times,Sign[exprsym[[1]]]==1,True]]];


(* ::Input::Initialization:: *)
momentumSum[expr_]:=Module[{exprsym,sign,label},
sign=If[canonicalOrderQ[expr]==True,1,-1];
exprsym=sign*expr;
label=If[Head@exprsym===Plus,"MOMSUM"<>StringReplace[ToString[CForm[exprsym//Expand]],{" + "->"Plus"," - "->"Minus","*"->"Times"}],ToString[CForm[exprsym//Expand]]];
Return[sign*ToExpression[label]]
];


(* ::Input::Initialization:: *)
invmomentumsum[expr_]:=Module[{s},s=StringReplace[ToString[expr],{"MOMSUM"->"","Plus"->"+","Minus"->"-","Times"->"*"}]];
invmomentumsumwithrepl[expr_,repl_]:=Module[{s},s=ToString[ToExpression[StringReplace[ToString[expr],{"MOMSUM"->"","Plus"->"+","Minus"->"-","Times"->"*"}]]/.repl]];
idinvmomentumsum[exprms_]:=ToString[exprms]~~","~~invmomentumsum[exprms];
idinvmomentumsums[expr_List]:="Multiply replace_("~~stringList[idinvmomentumsum/@expr]~~");";
idinvmomentumsumwithrepl[exprms_,repl_]:=ToString[exprms/.repl]~~","~~invmomentumsumwithrepl[exprms,repl];
idinvmomentumsumswithrepl[expr_List,repl_]:="Multiply replace_("~~stringList[Map[idinvmomentumsumwithrepl[#,repl]&,expr]]~~");";


(* ::Input::Initialization:: *)
replacevec3[mom_]:="id FTxvecs("~~ToString[mom]~~",lor1?)="~~"vecsx"~~ToString[mom]~~"(lor1);";

replacevec3inv[moms_List]:="Multiply replace_("~~stringList["vecsx"~~ToString[#]~~","~~ToString[#]&/@moms]~~");";


(* ::Input::Initialization:: *)
stringList[expr_List]:=StringJoin[Riffle[ToString/@expr,","]];
stringLines[expr_List]:=StringJoin[Riffle[expr,"\n"]];

formBlockArgument[block_String,level_Integer:5]:=block~~If[level===1,"","\n"~~stringLines@Table["argument;\n"~~block,{i,level-1}]~~"\n"~~stringLines@Table["endargument;",{i,level-1}]~~"\n"];

numToString[x_]:=If[Head[x]===Rational,ToString[Numerator[x]]~~"/"~~ToString[Denominator[x]],ToString[x]];


(* ::Input::Initialization:: *)
toGenericFormString[expr_]:=StringReplace[ToString[expr,InputForm],{"FormTracer`Private`"->""," + "->"+"," - "->"-"}];
replaceGroupTensors[expr_]:=StringReplace[expr,{
Shortest["FTxepsAdj["~~group__~~", "~~x__~~"]"]:>"e_("~~x~~")",
Shortest["FTxepsFund["~~group__~~", "~~x__~~"]"]:>"e_("~~x~~")",
Shortest["FTxdeltaAdj["~~group__~~", "~~x__~~", "~~y__~~"]"]:>"d_("~~x~~","~~y~~")",
Shortest["FTxdeltaFund["~~group__~~", "~~x__~~", "~~y__~~"]"]:>"d_("~~x~~","~~y~~")",
Shortest["FTxF["~~group__~~", "~~x__~~", "~~y__~~", "~~z__~~"]"]:>"f("~~x~~","~~y~~","~~z~~")",
Shortest["FTxT["~~group__~~", "~~x__~~", "~~y__~~", "~~z__~~"]"]:>"T("~~y~~","~~z~~","~~x~~")"
}];
replaceLorentzTensors[expr_]:=StringReplace[expr,{
Shortest["FTxgamma["~~x__~~", "~~y__~~", "~~z__~~"]"]:>"gamma("~~x~~","~~y~~","~~z~~")",
Shortest["FTxgamma5["~~x__~~", "~~y__~~"]"]:>"gamma(g5,"~~x~~","~~y~~")",
Shortest["FTxepsLorentz["~~x__~~"]"]:>"e_("~~x~~")",
Shortest["FTxdeltaLorentz["~~x__~~", "~~y__~~"]"]:>"d_("~~x~~","~~y~~")",
Shortest["FTxdeltaDirac["~~x__~~", "~~y__~~"]"]:>"d_("~~x~~","~~y~~")",
Shortest["FTxvec[0, "~~y__~~"]"]:>"0",
Shortest["FTxvec["~~x__~~", "~~y__~~"]"]:>""~~x~~"("~~y~~")",
Shortest["FTxsp["~~x__~~", "~~y__~~"]"]:>x~~"."~~y
}];
finalizeFormString[expr_]:=StringReplace[expr,{"["->"(","]"->")",", "->",","I"->"i_","Sqrt"->"sqrt"}];

toFormStringScalar[expr_]:=finalizeFormString[toGenericFormString[expr]];
toFormStringGroup[expr_]:=finalizeFormString[replaceGroupTensors[toGenericFormString[expr]]];
toFormStringLorentz[expr_]:=finalizeFormString[replaceLorentzTensors[toGenericFormString[expr]]];
toFormStringAll[expr_]:=finalizeFormString[replaceLorentzTensors[replaceGroupTensors[toGenericFormString[expr]]]];


(* ::Input::Initialization:: *)
generateLorentzFormExpressions[input_List,lorentzTermString_String]:=Module[{x=Reverse[input,3],vars={},termSummation={"Local ",lorentzTermString,"="},factorMultiplications={},spinorFactors={},structures,tmpFactorName},
(*ti = term index*)
(*si = short for structure index*)
(*ifi = short for inner factor index*)
Do[
AppendTo[termSummation,"+"<>lorentzTermString<>"T"<>ToString[ti]];
AppendTo[factorMultiplications,{"Local "<>lorentzTermString<>"T"<>ToString[ti]}];
Do[
AppendTo[factorMultiplications[[ti]],If[si===1,"=","*"]<>lorentzTermString<>"T"<>ToString[ti]<>"S"<>ToString[si]<>If[Length[x[[ti,si]]]===1,"F1",""]];
Do[
tmpFactorName=lorentzTermString<>"T"<>ToString[ti]<>"S"<>ToString[si]<>"F"<>ToString[ifi];
AppendTo[vars,"Local "<>tmpFactorName<>"="<>toFormStringLorentz[x[[ti,si,ifi]]]<>";\n"];
If[spinorFromExpr[x[[ti,si,ifi]]]=!={},AppendTo[spinorFactors,tmpFactorName]];
,{ifi,Length[x[[ti,si]]]}
];
,{si,Length[x[[ti]]]}
];
,{ti,Length[x]}
];
structures=Flatten[Table[{lorentzTermString<>"T"<>ToString[ti]<>"S"<>ToString[si],Length[x[[ti,si]]]},{ti,Length[x]},{si,Length[x[[ti]]]}],1];
Return[{StringJoin[vars],structures,StringJoin[Riffle[factorMultiplications,";\n"]]<>";\n"<>StringJoin[termSummation]<>";",spinorFactors}];
];


(* ::Input::Initialization:: *)
(* Private function *)
generateDiracLorentzContractionCode[lorentzSymbols_List,lorentzprerepl_String,vectorIds_String]:="Unhide "<>stringList[lorentzSymbols]<>";
"~~If[formLorentzTensorIdentities==={},"","
*** use Lorentz tensor identities ***
Repeat;
"~~stringLines[formLorentzTensorIdentities]~~"
EndRepeat;
.sort
"]~~If[combinedTensorIdentities==={},"","
*** inserts explicit expressions for combined Lorentz tensors ***
"~~stringLines[combinedTensorIdentities] ~~"
.sort
"]~~lorentzprerepl~~"
"~~If[finiteTenabled,generateVectorReplacementsFiniteT[vectorIds],""]~~"
"~~generateDiracContractionCode[]~~"
";

generateDisentangledDiracContractionCode[spinorFactors_List,lorentzprerepl_String]:=If[spinorFactors==={},"*** No Dirac traces to perform! ***\n\n","
*** Perform Dirac traces first ***
Unhide "<>stringList[spinorFactors]<>";
"~~lorentzprerepl~~"
"~~generateDiracContractionCode[]~~"
Hide "<>stringList[spinorFactors]<>";
.sort

"]; 

generateDisentangledLorentzContractionCode[structuresList_List,lorentzprerepl_String]:=Module[{contractionRound,contractionString={},structures=Cases[structuresList,Except[{_,1}]],trivialStructures=Cases[structuresList,{name_,1}:>name<>"F1"]},
For[contractionRound=Max[structures[[All,2]]]-1,contractionRound>=1,contractionRound--,
AppendTo[contractionString,"*** contraction round "<>ToString[contractionRound]<>"***\n"];
(*Drop*)
AppendTo[contractionString,"Drop "<>stringList[Join[
Cases[structures,{name_,factors_}/;factors==contractionRound+1:>name<>"F"<>ToString[contractionRound+1]],
Cases[structures,{name_,factors_}/;factors>contractionRound:>name<>"F"<>ToString[contractionRound]]
]]<>";\n"]; 
(*Local*)
Do[
AppendTo[contractionString,
"Local "<>First[structure]<>"="<>First[structure]<>If[contractionRound+1==Last[structure],"F"<>ToString[contractionRound+1],""]<>"*"<>First[structure]<>"F"<>ToString[contractionRound]<>";\n"];
,{structure,Cases[structures,{_,factors_}/;factors>contractionRound]}];
(*Contract Lorentz*)
(*applying post repl rules doesn't make sense after every contraction round since the momenta are guarded by MOMSUMxxx*)
AppendTo[contractionString,".sort\n\n"];
];
(*Unhide trivial structures for momentum replacements*)
If[Length[trivialStructures]>0,AppendTo[contractionString,"Unhide "<>stringList[trivialStructures]<>";\n.sort\n\n"];];

Return[StringJoin[contractionString]<>lorentzprerepl];
];


(* ::Input::Initialization:: *)
generateFormExpressions[expandedDiagrams_List,lorentzprerepl_String,vectorIds_String]:=Module[{generateSummationCode,tmpGroupVar,numberOfDiagrams=Length[expandedDiagrams],groupVariables=Table[{},{Length[groupTensorsList]}],lorentzVariables={},defList={},lorentzSummations={},groupSummations,diagramSummation,lorentzStructures={},diracFactors={},lorentzContractionCode},

If[disentangleLorentzStructures,
generateSummationCode[expr_,preString_,0]:=Module[{tmpLorVar=preString<>"LX",lorentzFormExpressions},
lorentzFormExpressions=generateLorentzFormExpressions[expr,tmpLorVar];
AppendTo[defList,lorentzFormExpressions[[1]]];
AppendTo[lorentzStructures,lorentzFormExpressions[[2]]];
AppendTo[lorentzSummations,lorentzFormExpressions[[3]]];
AppendTo[diracFactors,lorentzFormExpressions[[4]]];
Return[tmpLorVar];
];
,
generateSummationCode[expr_,preString_,0]:=Module[{tmpLorVar=preString<>"LX"},
AppendTo[defList,"Local "<>tmpLorVar<>"="<>toFormStringLorentz[expr]<>";\n"];
AppendTo[lorentzVariables,tmpLorVar];
Return[tmpLorVar];
];
];

generateSummationCode[expr_,preString_,group_]:=StringJoin@Table[
tmpGroupVar=preString<>"G"<>ToString[iGroupExpr];
AppendTo[groupVariables[[group]],tmpGroupVar];
AppendTo[defList,"Local "<>tmpGroupVar<>"="<>toFormStringGroup[expr[[iGroupExpr,1]]]<>";\n"];
"+"<>tmpGroupVar<>"*("<>generateSummationCode[expr[[iGroupExpr,2]],tmpGroupVar,group-1]<>")"
,{iGroupExpr,Length[expr]}];

groupSummations=Table[
AppendTo[defList,"Local D"<>ToString[iDia]<>"prefactor="<>toFormStringScalar[expandedDiagrams[[iDia,1]]]<>";\n"];
"Local FTxD"<>If[numberOfDiagrams===1,"",ToString[iDia]]<>"=D"<>ToString[iDia]<>"prefactor*("<>generateSummationCode[expandedDiagrams[[iDia,2]],"D"<>ToString[iDia],Length[groupTensorsList]]<>");"
,{iDia,numberOfDiagrams}];

diagramSummation=If[numberOfDiagrams===1,"","
.sort

Drop;
Local FTxD="<>StringJoin[Table["+FTxD"<>ToString[i],{i,numberOfDiagrams}]]<>";"];

lorentzContractionCode=If[disentangleLorentzStructures,
generateDisentangledDiracContractionCode[Flatten[diracFactors],lorentzprerepl]<>generateDisentangledLorentzContractionCode[Flatten[lorentzStructures,1],lorentzprerepl],
generateDiracLorentzContractionCode[lorentzVariables,lorentzprerepl,vectorIds]
];

Return[{
StringJoin[defList],
Map[stringList[#]&,Reverse[groupVariables]],
lorentzContractionCode,
If[disentangleLorentzStructures,stringLines[lorentzSummations]<>"\n",""]<>stringLines[groupSummations]<>diagramSummation
}];
];


(* ::Input::Initialization:: *)
measureEvaluationTime[False,message_String:"",arg_]:=ReleaseHold[arg];
measureEvaluationTime[True,message_String:"",arg_]:=Module[{res},
res=ReleaseHold[AbsoluteTiming[arg]];
Print[ReleaseHold[message],First[res]];
Last[res](*Return[] must not be used here*)
];
SetAttributes[measureEvaluationTime,HoldRest];
MeasureEvaluationTime[arg_,message_String:""]:=measureEvaluationTime[True,message,arg];
SetAttributes[MeasureEvaluationTime,HoldAll];


(* ::Input::Initialization:: *)
(*{momenta},{momentamomentumsum},{extramomenta},...*)
getAllIndices[expr_]:=Module[{momenta,momentaall,momentams},
momenta=DeleteDuplicates[momentumFromExpr[expr]];
momentaall=Union[momenta,Select[ToExpression[Flatten[Map[StringReplace[StringSplit[ToString[#],{"Plus","Minus","Times"}],"MOMSUM"->""]&,momenta]]],Not[NumericQ[#]]&]];
momentams=Select[momenta,StringMatchQ[ToString[#],RegularExpression["MOMSUM(\\S*)"]]&];
Join[{momenta,momentams,Complement[momentaall,momenta,momentams],lorentzFromExpr[expr],spinorFromExpr[expr]},getAdjGroupIndices[expr,#]&/@ groupNames,getFundGroupIndices[expr,#]&/@ groupNames]];
generatePrefixedList[prefix_String,length_Integer]:=ToExpression/@Table[prefix~~ToString[i],{i,length}];
getAllIndicesReplaced[l_List]:=Join[Table[generatePrefixedList[prefixListIndices[[i]],Length[l[[i]]]],{i,Length[l]}]];
generateReplList[from_,to_]:=Table[from[[gri1]]->to[[gri1]],{gri1,Length[from]}];


(* ::Input::Initialization:: *)
declareGenericDs[shortGroupName_String]:="Symbol "~~stringList@Map[#~~shortGroupName&,formColorPackageGenericD]~~";";

generateDeclareHeader[allindicesrepl_]:=If[dimVars==={},"","
*** declaring dimension symbols ***
Symbol "~~stringList[dimVars]~~";"]~~"

*** declaring vectors ***
AutoDeclare Vector "~~prefixListIndices[[1]]~~If[finiteTenabled,", vecsx",""]~~";

*** declaring Lorentz indices ***
dimension "~~ToString[First[lorentzDimensions]]~~";
Index g5=0;
Set setg5:g5;
AutoDeclare Index "~~prefixListIndices[[2]]~~";

*** declaring Dirac indices ***
dimension "~~ToString[Last[lorentzDimensions]]~~";
AutoDeclare Index "~~prefixListIndices[[3]]~~";
"~~If[Length[groupNames]==0,"","
*** declaring adjoint group indices ***
dimension NA;
AutoDeclare Index "~~stringList@Take[prefixListIndices,{Length[prefixListLorentzDirac]+1,Length[prefixListLorentzDirac]+Length[groupNames]}(*all adjoined prefixes*)]~~";

*** declaring fundamental group indices ***
dimension NR;
AutoDeclare Index "~~stringList@Take[prefixListIndices,-Length[groupNames](*all fundamental prefixes*)]~~";
"]~~If[partialtrace==False,"","
*** declare Lorentz and Dirac tensors
CFunction FTxdeltaLorentz,FTxdeltaDirac,FTxgamma,FTxgamma5,FTxepsLorentz;

*** declare index sets to distinguish deltas
Set lorIndices: "~~stringList[allindicesrepl[[2]]]~~";
Set spiIndices: "~~stringList[allindicesrepl[[3]]]~~";

"~~If[Length[groupNames]==0,"","
*** declare group names and tensors
Symbol "~~stringList[groupNames]~~";
CFunction FTxT,FTxF,FTxdeltaFund,FTxdeltaAdj"~~If[partialtrace,",FTxepsFund,FTxepsAdj",""]~~";

"~~stringLines[Table["*** "~~ToString@groupNames[[i]]~~" index sets
Set a"~~ToString@shortGroupNames[[i]]~~"Indices: "~~stringList[allindicesrepl[[i+3]]]~~";
Set f"~~ToString@shortGroupNames[[i]]~~"Indices: "~~stringList[allindicesrepl[[i+3+Length[groupNames]]]]~~";"
,{i,Length[shortGroupNames]}]]
]];


(* ::Input::Initialization:: *)
generateVectorReplacementsFiniteT[vectorIds_String]:="
********************************************************************************
* Replace vec3 with dummy momenta for finite T
* (to be done after inserting explicit tensor expressions)
********************************************************************************
"~~If[combinedTensorIdentities==={},"","* resolve numerical factors in vec and sp (required for combined tensors)
.sort
S tmpvecrepl1, tmpvecrepl2;
"~~formBlockArgument["
FactArg FTxvecs;
id FTxvecs(mom?,-1,1,lorx1?)=-FTxvecs(mom,lorx1);
id FTxvecs(tmpvecrepl1?,mom?,lorx1?)=tmpvecrepl1*FTxvecs(mom,lorx1);
FactArg FTxvec;
id FTxvec(mom?,-1,1,lorx1?)=-FTxvec(mom,lorx1);
id FTxvec(tmpvecrepl1?,mom?,lorx1?)=tmpvecrepl1*FTxvec(mom,lorx1);
Factarg FTxsp;
id FTxsp(tmpvecrepl1?,mom1?,tmpvecrepl2?,mom2?)=tmpvecrepl1*tmpvecrepl2*FTxsp(mom1,mom2);
id FTxsp(tmpvecrepl1?,mom1?,mom2?)=tmpvecrepl1*FTxsp(mom1,mom2);
id FTxsp(mom1?,tmpvecrepl1?,mom2?)=tmpvecrepl1*FTxsp(mom1,mom2);
id FTxsp(mom1?,-1,1,mom2?)=-FTxsp(mom1,mom2);
id FTxsp(mom1?,-1,1,tmpvecrepl1?,mom2?)=-tmpvecrepl1*FTxsp(mom1,mom2);
id FTxsp(tmpvecrepl1?,mom1?,mom2?,-1,1)=-tmpvecrepl1*FTxsp(mom1,mom2);
id FTxsp(mom1?,mom2?,-1,1)=-FTxsp(mom1,mom2);
id FTxsp(mom1?,-1,1,mom2?,-1,1)=FTxsp(mom1,mom2);
Factarg FTxsps;
id FTxsps(tmpvecrepl1?,mom1?,tmpvecrepl2?,mom2?)=tmpvecrepl1*tmpvecrepl2*FTxsps(mom1,mom2);
id FTxsps(tmpvecrepl1?,mom1?,mom2?)=tmpvecrepl1*FTxsps(mom1,mom2);
id FTxsps(mom1?,tmpvecrepl1?,mom2?)=tmpvecrepl1*FTxsps(mom1,mom2);
id FTxsps(mom1?,-1,1,mom2?)=-FTxsps(mom1,mom2);
id FTxsps(mom1?,-1,1,tmpvecrepl1?,mom2?)=-tmpvecrepl1*FTxsps(mom1,mom2);
id FTxsps(tmpvecrepl1?,mom1?,mom2?,-1,1)=-tmpvecrepl1*FTxsps(mom1,mom2);
id FTxsps(mom1?,mom2?,-1,1)=-FTxsps(mom1,mom2);
id FTxsps(mom1?,-1,1,mom2?,-1,1)=FTxsps(mom1,mom2);"]]~~"
"~~formBlockArgument["id FTxvecs(mom1?,0)=0;\n"~~vectorIds]~~"
.sort";

undoCombinedMomentaCode[momentaIds_String]:=If[momentaIds==="","","
*** undo combined momentum labels ***
"~~momentaIds~~"
.sort"];


(* ::Input::Initialization:: *)
generateDiracContractionCode[]:="
********************************************************************************
* Performs Lorentz/Dirac contraction
********************************************************************************

*** combine Dirac matrices to Dirac string ***
repeat id gamma(?lor1,spi1?,spi2?)*gamma(?lor2,spi2?,spi3?)=gamma(?lor1,?lor2,spi1,spi3);
.sort

*** convert Dirac strings without open indices to FORM gamma matrices ***
unittrace "~~ToString[Last[lorentzDimensions]]~~";
"~~If[First[lorentzDimensions]===4,"
Repeat;
contract 0;
id once gamma(?mom1,spi1?,spi1?)= g_(1,?mom1);
id g_(1,g5)=g_(1,5_);
Trace4 1;
EndRepeat;
",If[fastgamma5tracedneq4==True,"#define FastGamma5Trace \"1\"",""]~~"
* handle gamma5s

* guard external epsilons
id e_(lorx1?,lorx2?,lorx3?,lorx4?)=FTxeExt(lorx1,lorx2,lorx3,lorx4);

Repeat;
if( match(gamma(?mom1, spi1?,spi1?)));
#call PreDiracTrace5
* first contract external epsilons (only those related to current spin line)
repeat id FTxTr(?lorx1,lorx2?,?lorx3)*FTxeExt(?lorx4,lorx2?,?lorx5)=FTxTr(?lorx1,lorx2,?lorx3)*e_(?lorx4,lorx2,?lorx5);
repeat id FTxeInt(?lorx1,lorx2?,?lorx3)*FTxeExt(?lorx4,lorx2?,?lorx5)=FTxeInt(?lorx1,lorx2,?lorx3)*e_(?lorx4,lorx2,?lorx5);
contract 0;
*id e_(lorx1?,lorx2?,lorx3?,lorx4?)=FTxeExt(lorx1,lorx2,lorx3,lorx4);

* now contract internal epsilons (only those related to current spin line)
repeat id FTxTr(?lorx1,lorx2?,?lorx3)*FTxeInt(?lorx4,lorx2?,?lorx5)=FTxTr(?lorx1,lorx2,?lorx3)*e_(?lorx4,lorx2,?lorx5);
repeat id FTxeInt(?lorx1,lorx2?,?lorx3)*e_(lorx2?,lorx4?,lorx5?,lorx6?)=e_(?lorx1,lorx2,?lorx3)*e_(lorx2,lorx4,lorx5,lorx6);
contract 0;
* id e_(lorx1?,lorx2?,lorx3?,lorx4?)=FTxeInt(lorx1,lorx2,lorx3,lorx4);
endif;
EndRepeat;
.sort
* perform actual dirac traces
Repeat;
id,once,FTxTr(?a) = g_(1,?a);
Tracen,1;
EndRepeat;
*convert everything to standard epsilons for output
id FTxeInt(?lorx)=e_(?lorx);
id FTxeExt(?lorx)=e_(?lorx);

"]~~"
.sort";


(* ::Input::Initialization:: *)
generateGroupContractionCode[id_Integer,groupVariables_List,groupprerepl_,grouppostrepl_]:="
********************************************************************************
* Perform "~~ToString[groupNames[[id]]]~~" trace
********************************************************************************
"~~If[id==1,"Hide;\nNhide "~~groupVariables[[id]]~~";","Unhide "~~groupVariables[[id]]~~";"]~~"
"~~formPreGroupTraceIdentities[[id]]~~If[groupprerepl[[id]]=!="","
*** user-defined prerepl ***
"~~groupprerepl[[id]],""]~~"
"~~If[groupTracingAlgorithms[[id,3]]>0,".sort"~~If[groupTracingAlgorithms[[id,3]]==1,"
*** set the dimension to NA for sums ***
Dimension NA;","
*** set the dimension to NR for sums ***
Dimension NR;"],""]~~"
contract 0;
#call "~~groupTracingAlgorithms[[id,1]]~~"
.sort"~~If[grouppostrepl[[id]]=!="","
*** user-defined postrepl ***
"~~grouppostrepl[[id]],""]~~"
"~~If[partialtrace,"*undo Ts for partial trace
repeat;
id,once,T(f"~~shortGroupNames[[id]]~~"x1?,f"~~shortGroupNames[[id]]~~"x2?,?a,a"~~shortGroupNames[[id]]~~"x1?,a"~~shortGroupNames[[id]]~~"x2?) = T(f"~~shortGroupNames[[id]]~~"x1,f"~~shortGroupNames[[id]]~~"x3,?a,a"~~shortGroupNames[[id]]~~"x1)*T(f"~~shortGroupNames[[id]]~~"x3,f"~~shortGroupNames[[id]]~~"x2,a"~~shortGroupNames[[id]]~~"x2); 
sum f"~~shortGroupNames[[id]]~~"x3;
endrepeat;
*replace epsilon
#call replaceepsilon
",""]~~"
"~~formPostGroupRenamingRules[[id]]~~"
"~~formGenericDReplacementRules[[id]]~~"
"~~If[partialtrace,formBlockArgument[formPostGroupTensorRenamingRules[[id]],1],""]~~"
.sort
Hide "~~groupVariables[[id]]~~";
.sort";

generateExtraGroupPrereplLists[expr_List,listhead_]:=stringLines[Last/@Select[Select[expr,Head@#===List&],#[[1]]==listhead&]];


(* ::Input::Initialization:: *)
generateBracketingString[bracket_]:="
bracket "~~stringList[bracket]~~";
.sort

"~~stringLines@Table["Local FTxDcoeff"~~bra~~"=FTxD["~~bra~~"];",{bra,Join[{"1"},ToString/@bracket]}]~~"
.sort";

generateExportCode[format_String,bracket_List,optimization_String,resFileName_String,exportResVar_String,exportTmpVar_String,exportVarType_String]:=Module[{absResFileName,exportString={},tmpFileName,insertPosition,absResFileNameBracket},
(* use different absResFileName for Windows and Unix *)
absResFileName=If[$OperatingSystem==="Windows",
StringReplace[If[StringTake[resFileName,{2,3}]===":\\",resFileName,FileNameJoin[{Directory[],resFileName}]],"\\"->"\\\\"],
If[StringTake[resFileName,1]===$PathnameSeparator,resFileName,FileNameJoin[{Directory[],resFileName}]]
];
(* import to Mathematica *)
If[format==="mathematica",
If[Length[bracket]>0,Message[FormTrace::nobracketing];Abort[];];
Return["
Format mathematica;
#write <"~~absResFileName~~"> \"(%E)\", FTxD
"];
];
(* export to C *)
AppendTo[exportString,"
ExtraSymbols,array,"~~exportTmpVar~~";
Format "~~format~~";
Format "~~optimization~~";
"];
(* generate a separate file for each bracketing coefficient if bracketing is enabled*)
If[Length[bracket]>0,
tmpFileName=Last[FileNameSplit[absResFileName]];(*extract pure file name just in case the path contains dots*)
insertPosition=If[StringContainsQ[tmpFileName,"."],First[Last[StringPosition[tmpFileName,"."]]-StringLength[tmpFileName]-2],0];
AppendTo[exportString,"
"<>StringJoin@@Table[absResFileNameBracket=If[insertPosition===0,absResFileName<>bracketStr,StringInsert[absResFileName,"_"<>bracketStr, insertPosition]];"
*** coefficient "~~bracketStr~~" ***
#if termsin(FTxDcoeff"~~bracketStr~~") == 0
#write<"~~absResFileNameBracket~~">\""~~exportResVar~~"_"~~ToUpperCase[bracketStr]~~"= %e;\",FTxDcoeff"~~bracketStr~~"
#else
#optimize FTxDcoeff"~~bracketStr~~";"<>If[format==="C","
#write<"~~absResFileNameBracket~~">\""~~exportVarType~~" "~~exportTmpVar~~"[{`optimmaxvar_'+1}];\"",""]<>If[format==="fortran90","
#write<"~~absResFileNameBracket~~">\""~~exportVarType~~" :: "~~exportTmpVar~~"({`optimmaxvar_'+1})\"",""]<>"
#write<"~~absResFileNameBracket~~">\"%O\"
#write<"~~absResFileNameBracket~~">\""~~exportResVar~~"_"~~ToUpperCase[bracketStr]~~"= %e;\",FTxDcoeff"~~bracketStr~~"
#clearoptimize
#endif
",{bracketStr,Join[{"1"},ToString/@bracket]}]];
,
AppendTo[exportString,"
#if termsin(FTxD) == 0
#write<"~~absResFileName~~">\""~~exportResVar~~"= %e;\",FTxD
#else
#optimize FTxD;"<>If[format==="C","
#write<"~~absResFileName~~">\""~~exportVarType~~" "~~exportTmpVar~~"[{`optimmaxvar_'+1}];\"",""]<>If[format==="fortran90","
#write<"~~absResFileName~~">\""~~exportVarType~~" :: "~~exportTmpVar~~"({`optimmaxvar_'+1})\"",""]<>"
#write<"~~absResFileName~~">\"%O\"
#write<"~~absResFileName~~">\""~~exportResVar~~"= %e;\",FTxD
#clearoptimize
#endif
"];
];
Return[StringJoin[exportString]];
];


(* ::Input::Initialization:: *)
generateFormFile[expr_,formFileName_String,resFileName_String,optimization_String,format_String,prerepl_List,postrepl_List,bracket_List,exportResVar_String,exportTmpVar_String,exportVarType_String]:=Module[{replacemomenta,idmomenta1,id3momenta1,id3momenta1inv,momentams,momenta,momentaall,allindicesextracted,allindices,allindicesrepl,indicesreplrule,momreplrule,mathematicavariablelistsreturn,preambleprerepl,generalprerepl,lorentzprerepl,groupprerepl,generalpostrepl,lorentzpostrepl,grouppostrepl,formCode,file,exprlst,formexpr,openIndicesString},
If[expr===Null,Abort[]];

measureEvaluationTime[debuggingMode,"Time needed for converting input, extracting momenta and indices: ",
(*convert input*)
exprlst=Map[#//.combinedMomentumRepl&,If[Head[expr]===List,expr,{expr}]];
(*check for open indices*)

If[(partialtrace==False||format=!="mathematica")&&AnyTrue[exprlst,getOpenIndices[#]=!={}&],
openIndicesString=stringList[ToString/@Map[getOpenIndices[#]&,exprlst]];
If[partialtrace==False,Message[FormTrace::openindices,openIndicesString]];
If[format=!="mathematica",Message[FormTrace::openindicesexport,openIndicesString]];
Abort[];
];
(*extract indices*)
allindicesextracted=getAllIndices[Plus@@exprlst];(*separates three different kinds of momenta*)
allindices=Join[{Flatten[allindicesextracted[[1;;3;;2]]]},allindicesextracted[[4;;]]];(*same as above, but all momenta combined*)
If[Not[DuplicateFreeQ[Flatten[allindices]]],Message[GenerateFormFile::duplicateindicesnames];Abort[];];
allindicesrepl=getAllIndicesReplaced[allindices];(*format: {momX,lorX,spiX,adj1,adj2,...,adjN,fund1,fund2,...,fundN*)
indicesreplrule=generateReplList[Flatten[allindices[[2;;]]],Flatten[allindicesrepl[[2;;]]]];
replacemomenta=If[Or@@Map[Not[StringFreeQ[ToString[#,InputForm,CharacterEncoding->"ASCII"],"\\"]]&,allindicesextracted[[1]]],True,False];
momreplrule=If[replacemomenta,generateReplList[allindices[[1]],allindicesrepl[[1]]],{}];
mathematicavariablelistsreturn=If[format==="mathematica",Join[If[replacemomenta,{{allindices[[1]],allindicesrepl[[1]]}},{{{},{}}}],If[partialtrace,Partition[Riffle[allindices[[2;;]],allindicesrepl[[2;;]]],2],{{{},{}}}]],{{{},{}},{{},{}}}];
momenta=allindicesextracted[[1]];
momentams=allindicesextracted[[2]];
momentaall=allindices[[1]];
exprlst=exprlst/.Dispatch[Join[momreplrule,indicesreplrule]];

If[Not[replacemomenta],
(*no momentum replacement required*)
idmomenta1=If[Length[momentams]>0,idinvmomentumsums[momentams],""];
id3momenta1=If[finiteTenabled ,stringLines[replacevec3/@momenta],""];
id3momenta1inv=If[finiteTenabled,replacevec3inv[momenta],""];,
(*momentum replacement required*)
idmomenta1=If[Length[momentams]>0,idinvmomentumsumswithrepl[momentams,momreplrule],""];
id3momenta1=If[finiteTenabled,stringLines[replacevec3/@(momenta/.momreplrule)],""];
id3momenta1inv=If[finiteTenabled,replacevec3inv[momenta/.momreplrule],""];
];
If[format=!="mathematica",
(*check extra vars list for forbidden special characters*)
If[Or@@Map[Not[StringFreeQ[ToString[#,InputForm,CharacterEncoding->"ASCII"],"\\"]]&,extraFormVarsList[[All,1]]],Message[FormTrace::specialchar];Abort[];];
(*check momenta for forbidden special characters*)
If[replacemomenta,Message[FormTrace::specialcharmomentum];Abort[];];
];

(*prerepl and postrepl list handling*)
If[Not@AllTrue[Head/@prerepl,#===List||#===String&],Message[FormTrace::invalidprerepl];Abort[];];
preambleprerepl=generateExtraGroupPrereplLists[prerepl,PreambleFormRule];
generalprerepl=stringLines@Select[prerepl,Head@#=!=List&];
lorentzprerepl=generateExtraGroupPrereplLists[prerepl,LorentzFormRule];
groupprerepl=Map[generateExtraGroupPrereplLists[prerepl,#]&,groupNames];
If[Not@AllTrue[Head/@postrepl,#===List||#===String&],Message[FormTrace::invalidpostrepl];Abort[];];
generalpostrepl=stringLines@Select[postrepl,Head@#=!=List&];
lorentzpostrepl=generateExtraGroupPrereplLists[postrepl,LorentzFormRule];
grouppostrepl=Map[generateExtraGroupPrereplLists[postrepl,#]&,groupNames];
];

measureEvaluationTime[debuggingMode,"Time needed for expansion and generation of FORM expressions: ",
formexpr=generateFormExpressions[removeSquaredTensors[expandTerms[exprlst]]/.dimVarRulesInput,If[lorentzprerepl==="","","*** user-defined prerepl ***\n"<>lorentzprerepl<>"\n.sort\n"],id3momenta1];
];

measureEvaluationTime[debuggingMode,"Time needed for string generation: ",
(*put strings together; the result is the FORM program*)
formCode=stringLines[Map["#include- "<>FileNameJoin[{formTracerDirectory,"Header",#}]&,Union[groupTracingAlgorithms[[All,2]],If[First[lorentzDimensions]=!=4,{"dirac.h"},{}]]]]~~"
"~~If[partialtrace,"#include- "<>FileNameJoin[{formTracerDirectory,"Header","misc.h"}],""]~~"
"~~If[preambleprerepl=!="","
********************************************************************************
* user-defined preamble
********************************************************************************
"~~preambleprerepl~~"
",""]~~"
********************************************************************************
***************************MAIN PROGRAM*****************************************
********************************************************************************

********************************************************************************
* General declarations
********************************************************************************
"~~generateDeclareHeader[allindicesrepl]~~"
"~~If[MemberQ[groupTracingAlgorithms[[All,2]],"color.h"],"*** declaring color package symbol repacements
AutoDeclare Vector "~~prefixColorPackagegrpvecsym~~";
AutoDeclare CFunction "~~stringList[Map[prefixColorPackageGenericD~~#&,Join[{postfixColorPackagesp~~"(symmetric)"},formColorPackageGenericD]]]~~";",""]~~"

"~~If[Not[replacemomenta]&&Length[momentaall]>0,"
*** declare vectors explicitly ***
Vector "~~ stringList[momentaall]~~";",""]~~"
Set setvec:"~~stringList[If[replacemomenta,momenta/.momreplrule,momenta]]~~";
"~~If[finiteTenabled ,"
Set setvecs:"~~stringList[StringJoin["vecsx",ToString[#]]&/@If[replacemomenta,momentaall/.momreplrule,momentaall]]~~";"
,""]~~"
"~~If[combinedTensorNames==={},"","CFunction "<>stringList[combinedTensorNames]<>";"]~~"
AutoDeclare CFunction "~~stringList[formCFunctionAutoDeclareList]~~";
"~~If[format==="mathematica"||extraFormVarsListExportDeclare=={},"","CFunction "<>stringList[Complement[extraFormVarsListExportDeclare,ToString/@momentaall]]<>";"]~~"
CFunction pow,sqrt,Pi,gamma,FTxsp(symmetric),FTxvec"~~If[finiteTenabled,",FTxvecs,FTxsps(symmetric)",""]~~";
"~~If[First[lorentzDimensions]=!=4,"CFunction FTxTr, FTxTr2, FTxTr3, FTxeInt, FTxeExt;",""]~~"
*** turn off runtime statistics ***
Off statistics;
.sort

********************************************************************************
* Decomposed input
********************************************************************************
"~~formexpr[[1]]~~"
.sort

"~~If[generalprerepl=!="","
********************************************************************************
* Apply general pre replacements
********************************************************************************
"~~generalprerepl~~"
.sort
",""]~~"

"~~If[lorentzTensorReplacementRulesInput=!={}&&disentangleLorentzStructures
(*if disentangleLorentzStructures\[Equal]False, they are only applied to the Lorentz variables later*),"
********************************************************************************
* General Lorentz replacements
********************************************************************************
"~~If[combinedTensorIdentities==={},""(* in this case they are only applied to the Lorentz variables *),"
*** inserts explicit expressions for combined Lorentz tensors ***
"~~stringLines[combinedTensorIdentities] ~~"
.sort"]~~"
"~~If[finiteTenabled,generateVectorReplacementsFiniteT[id3momenta1],""],""]~~"

"~~stringLines@Table[generateGroupContractionCode[i,formexpr[[2]],groupprerepl,grouppostrepl],{i,Length[groupNames]}]~~"

"~~If[lorentzTensorReplacementRulesInput==={},"","
********************************************************************************
* Lorentz and Dirac contraction
********************************************************************************
*** set dimension to Lorenz dim for epsilons ***
Dimension "~~ToString[First[lorentzDimensions]]~~";
.sort

"~~formexpr[[3]]~~"
"~~If[partialtrace,"
**********************************************************************************
*partial trace manipulations
**********************************************************************************
*replace vectors 
repeat id gamma(?lor1,momx1?setvec,?lor2,spix1?,spix2?)=gamma(?lor1,FTxvec(momx1),?lor2,spix1,spix2);
repeat id gamma(?lor1,g5,?lor2,spix1?,spix2?)=gamma(?lor1,5,?lor2,spix1,spix2);"~~If[finiteTenabled && Length[momenta]>0,"
repeat gamma(?lor1,momx1?setvecs,?lor2,spix1?,spix2?)=gamma(?lor1,FTxvecs(momx1),?lor2,spix1,spix2);
",""]~~"

*replace epsilon and pull out vectors 
#call replaceepsilon
multiply replace_(FTxeps,FTxepsLorentz);

Repeat;
	id,once FTxepsLorentz(?lorx1,momx1?setvec,?lorx2)=FTxvec(momx1,lorx3)*FTxepsLorentz(?lorx1,lorx3,?lorx2);"~~If[finiteTenabled&&Length[momenta]>0,"
	id,once FTxepsLorentz(?lorx1,momx1?setvecs,?lorx2)=FTxvecs(momx1,lorx4)*FTxepsLorentz(?lorx1,lorx4,?lorx2);
	sum lorx4;",""]~~" 
	sum lorx3;
EndRepeat;",""]~~"
********************************************************************************
* Rewriting scalar products and momentum labels
********************************************************************************
*** rewrite scalar products and vectors with numeric indices ***
"~~formBlockArgument[If[finiteTenabled,"
id mom1?!setvecs.mom2?!setvecs=FTxsp(mom1,mom2);
id mom1?!setvecs.mom2?!setvecs^-1=FTxsp(mom1,mom2)^-1;
id mom1?setvecs.mom2?=FTxsps(mom1,mom2);
id mom1?setvecs.mom2?^-1=FTxsps(mom1,mom2)^-1;
id mom1?setvecs(0)=0;
id mom1?!setvecs(lor1?fixed_)=FTxvec(mom1,lor1);
id mom1?setvecs(lor1?fixed_)=FTxvecs(mom1,lor1);
","
id mom1?.mom2?=FTxsp(mom1,mom2);
id mom1?.mom2?^-1=FTxsp(mom1,mom2)^-1;
id mom1?(lor1?fixed_)=FTxvec(mom1,lor1);
"]]~~"
"~~If[finiteTenabled,id3momenta1inv,""]~~"
.sort

"~~If[partialtrace,"
********************************************************************************
* Identifications performed after the Lorentz/Dirac trace
********************************************************************************
*** replace tensors *** "~~formBlockArgument["
id d_(lor1?lorIndices,lor2?)=FTxdeltaLorentz(lor1,lor2);
id d_(spi1?spiIndices,spi2?)=FTxdeltaDirac(spi1,spi2);
id gamma(g5,spi1?,spi2?)=FTxgamma5(spi1,spi2);
id gamma(lor1?!setg5,spi1?,spi2?)=FTxgamma(lor1,spi1,spi2);
Multiply replace_(gamma,FTxgamma);
",1]~~"
*** replace momenta ***
"~~formBlockArgument["id mom1?(lor1?)=FTxvec(mom1,lor1);",1]~~"
.sort",""]~~"
"~~If[lorentzpostrepl=!="","
"~~undoCombinedMomentaCode[idmomenta1]~~"
*** user-defined postrepl ***
"~~lorentzpostrepl~~"
.sort",""]~~"
"]~~"
********************************************************************************
* Putting terms together
********************************************************************************
Drop;
"~~formexpr[[4]]~~"
.sort

"~~undoCombinedMomentaCode[idmomenta1]~~"

"~~If[format=!="mathematica"&&extraFormVarsListOutputConversionExport=!="","
*** reinsert variables that had to be protected since they are internally used by the color package ***
"<>If[Length[groupNames]===0(*in this case the problematic vars are not declared*),"Symbol "<>stringList[forbiddenFormVars]<>";",""]<>"
"<>formBlockArgument[extraFormVarsListOutputConversionExport]<>"
.sort",""]~~"
"~~If[dimReplVarsSynonyms==={},"","
*** re-insert replaced dimension variables ***
Multiply replace_("<>stringList@Flatten[Reverse/@dimReplVarsSynonyms]<>");
.sort"]~~"
"~~If[generalpostrepl=!="","
********************************************************************************
* Apply general post replacements
********************************************************************************
"~~generalpostrepl~~"
.sort
",""]~~"
"~~If[Length[bracket]>0,"
********************************************************************************
* Perform bracketing
********************************************************************************
"~~generateBracketingString[bracket]~~"
",""]~~"
********************************************************************************
* Output/export
********************************************************************************
"~~generateExportCode[format,bracket,optimization,resFileName,exportResVar,exportTmpVar,exportVarType]~~"
.end";
(*write form program*)
file=OpenWrite[formFileName];
WriteString[file,formCode];
Close[file];
];
Return[mathematicavariablelistsreturn];
];

GenerateFormFile[expr_,formFileName_String,resFileName_String,optimization_String:"",format_String:"mathematica",prerepl_List:{},postrepl_List:{},bracket_List:{},exportResVar_String:"expr",exportTmpVar_String:"w",exportVarType_String:"double"]:=generateFormFile[convertInput[expr,format==="mathematica"],formFileName,resFileName,optimization,format,prerepl,postrepl,bracket,exportResVar,exportTmpVar,exportVarType];


(* ::Input::Initialization:: *)
importFormResult[filename_String,deleteImportedFile_]:=Module[{result},
If[Not[FileExistsQ[filename]],Message[ImportFormResult::noformoutput];Abort[];];
result=ToExpression[StringReplace[ReadString[filename],Join[{"\n"->" ","sqrt"->"Sqrt","i_"-> "I","pow["->"Power["},If[partialtrace,{Shortest["N"~~x:DigitCharacter..~~"_?"]:>ToString[tempPartialTraceDummy]~~"["~~x~~"]"},{}]]]];
If[deleteImportedFile,DeleteFile[filename]];
If[result===Global`FTxsp[Global`mom1, Global`mom2],Message[FormTrace::formfailed];Abort[];];
Return[result];
];
ImportFormResult[filename_String,deleteImportedFile_:False]:=convertPartiallyTracedOutput[importFormResult[filename,deleteImportedFile]];


(* ::Input::Initialization:: *)
FormTrace[___]:=Message[FormTrace::badarg];
FormTrace[expr_,prerepl_List:{},postrepl_List:{},filename_:"",bracket_List:{},exportResVar_String:"expr",exportTmpVar_String:"w",exportVarType_String:"double"]:=Module[{timeString,formFile,resFile,format,optimization,formProcessResult,formConsoleOutput,formErrors,retValVariableLists,importedRes},
If[expr===Null||checkFormExecutable[]==False,Abort[];];

timeString=StringJoin@Riffle[Join[Map[If[StringLength[ToString[#]]==1,"0"~~ToString[#],ToString[#]]&,Date[]],{ToString[Unique["f"]]}],"-"];
If[debuggingMode&&Not[DirectoryQ[cacheFilesDirectory]],CreateDirectory[cacheFilesDirectory]];
formFile=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"runform_"<>timeString<>".frm"}];

If[filename===""(* means default case, result is imported back into Mathematica *),
resFile=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"res_"<>timeString<>".txt"}];
optimization="";
format="mathematica";
,
If[Head[filename]===String,
(* default with filename provided is O2 optimized c code *)
resFile=filename;
optimization="O2";
format="C";
,
(* filename is list {filename, optimization, format} *)
If[Head[filename]=!=List,Message[FormTrace::badarg];Abort[];];
resFile=First[filename];
optimization=If[Length[filename]>1,filename[[2]],"O2"];
format=If[Length[filename]>2,filename[[3]],"C"];
];
];

retValVariableLists=generateFormFile[convertInput[expr,format==="mathematica"],formFile,resFile,optimization,format,prerepl,postrepl,bracket,exportResVar,exportTmpVar,exportVarType];

measureEvaluationTime[debuggingMode,"Time needed by Form: ",
formProcessResult=RunProcess[{formExecutable,"-q",formFile}];
(* check exit code *)
If[formProcessResult["ExitCode"]=!=0,Message[FormTrace::formeexitcode,formProcessResult["ExitCode"]]];
(* check output string for error messages *)
formConsoleOutput=formProcessResult["StandardOutput"];
If[Not[StringFreeQ[formConsoleOutput,formFile]](*FORM starts error messages with full file name*),
formErrors=Flatten@StringCases[formConsoleOutput,Shortest[formFile~~msg1__~~"\n"~~msg2__~~"\n"]:>StringSplit[msg1<>"\n"<>msg2,formFile]];
Map[Message[FormTrace::formerror,#]&,formErrors];
Abort[];
];
];

If[!debuggingMode,DeleteFile[formFile]];
If[filename==="",
measureEvaluationTime[debuggingMode,"Time needed to import the result: ",
importedRes=importFormResult[resFile,!debuggingMode];
Return[If[partialtrace,convertPartiallyTracedOutput[importedRes/.Global`FTxgamma[a_,b___,c_,d_,e_]->Global`FTxgamma[{a,b,c},d,e],retValVariableLists],convertTracedOutput[importedRes,retValVariableLists]]];
]
]
];


(* ::Input::Initialization:: *)
If[ToString[Context[URLDownload]]=!="System`",URLDownload=URLSave];
If[ToString[Context[ReadString]]=!="System`",ReadString[fn_String] :=Import[fn,"Text"]];
If[ToString[Context[FirstPosition]]=!="System`",FirstPosition[list_,item_]:=First[Position[list,item]]];
If[ToString[Context[FirstCase]]=!="System`",FirstCase[list_,patt_]:=First[Cases[list,patt]]];
If[ToString[Context[DuplicateFreeQ]]=!="System`",DuplicateFreeQ[lst_List]:=If[Length[DeleteDuplicates[Map[Count[lst,#]&,lst]]]>1,False,True]];


(* ::Input::Initialization:: *)
End[];
Protect@@Names["FormTracer`*"];
EndPackage[];
